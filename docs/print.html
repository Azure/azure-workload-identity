<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Azure AD Workload Identity</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/managed-clusters.html"><strong aria-hidden="true">1.1.</strong> Managed Clusters</a></li><li class="chapter-item expanded "><a href="installation/self-managed-clusters.html"><strong aria-hidden="true">1.2.</strong> Self-Managed Clusters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/self-managed-clusters/service-account-key-generation.html"><strong aria-hidden="true">1.2.1.</strong> Service Account Key Generation</a></li><li class="chapter-item expanded "><a href="installation/self-managed-clusters/oidc-issuer.html"><strong aria-hidden="true">1.2.2.</strong> OpenID Connect Issuer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/self-managed-clusters/oidc-issuer/discovery-document.html"><strong aria-hidden="true">1.2.2.1.</strong> Discovery Document</a></li><li class="chapter-item expanded "><a href="installation/self-managed-clusters/oidc-issuer/jwks.html"><strong aria-hidden="true">1.2.2.2.</strong> JSON Web Key Sets (JWKS)</a></li></ol></li><li class="chapter-item expanded "><a href="installation/self-managed-clusters/configurations.html"><strong aria-hidden="true">1.2.3.</strong> Configurations</a></li></ol></li><li class="chapter-item expanded "><a href="installation/mutating-admission-webhook.html"><strong aria-hidden="true">1.3.</strong> Mutating Admission Webhook</a></li><li class="chapter-item expanded "><a href="installation/azwi.html"><strong aria-hidden="true">1.4.</strong> Azure AD Workload Identity CLI (azwi)</a></li></ol></li><li class="chapter-item expanded "><a href="quick-start.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">3.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="topics.html"><strong aria-hidden="true">4.</strong> Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topics/service-account-labels-and-annotations.html"><strong aria-hidden="true">4.1.</strong> Service Account Labels And Annotations</a></li><li class="chapter-item expanded "><a href="topics/federated-identity-credential.html"><strong aria-hidden="true">4.2.</strong> Federated Identity Credential</a></li><li class="chapter-item expanded "><a href="topics/azwi.html"><strong aria-hidden="true">4.3.</strong> Azure Workload Identity CLI (azwi)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topics/azwi/serviceaccount-create.html"><strong aria-hidden="true">4.3.1.</strong> azwi serviceaccount create</a></li><li class="chapter-item expanded "><a href="topics/azwi/serviceaccount-delete.html"><strong aria-hidden="true">4.3.2.</strong> azwi serviceaccount delete</a></li><li class="chapter-item expanded "><a href="topics/azwi/jwks.html"><strong aria-hidden="true">4.3.3.</strong> azwi jwks</a></li></ol></li><li class="chapter-item expanded "><a href="topics/self-managed-clusters.html"><strong aria-hidden="true">4.4.</strong> Self-Managed Clusters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topics/self-managed-clusters/service-account-key-rotation.html"><strong aria-hidden="true">4.4.1.</strong> Service Account Key Rotation</a></li><li class="chapter-item expanded "><a href="topics/self-managed-clusters/examples.html"><strong aria-hidden="true">4.4.2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topics/self-managed-clusters/examples/kind.html"><strong aria-hidden="true">4.4.2.1.</strong> Kubernetes in Docker (kind)</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="topics/language-specific-examples.html"><strong aria-hidden="true">4.5.</strong> Language-Specific Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topics/language-specific-examples/azure-identity-sdk.html"><strong aria-hidden="true">4.5.1.</strong> Azure Identity client libraries</a></li><li class="chapter-item expanded "><a href="topics/language-specific-examples/msal.html"><strong aria-hidden="true">4.5.2.</strong> Microsoft Authentication Library (MSAL)</a></li></ol></li><li class="chapter-item expanded "><a href="topics/metrics.html"><strong aria-hidden="true">4.6.</strong> Metrics</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">5.</strong> Frequently Asked Questions</a></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">6.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="known-issues.html"><strong aria-hidden="true">7.</strong> Known Issues</a></li><li class="chapter-item expanded "><a href="development.html"><strong aria-hidden="true">8.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/releasing.html"><strong aria-hidden="true">8.1.</strong> Releasing</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">9.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="code-of-conduct.html"><strong aria-hidden="true">10.</strong> Code of Conduct</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Azure AD Workload Identity</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/Azure/azure-workload-identity" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Workloads deployed in Kubernetes clusters require Azure AD application credentials or managed identities to access Azure AD protected resources, such as Azure Key Vault and Microsoft Graph. The <a href="https://github.com/Azure/aad-pod-identity">Azure AD Pod Identity</a> open-source project provided a way to avoid needing these secrets, by using Azure managed identities.</p>
<p>Azure AD Workload Identity for Kubernetes integrates with the capabilities native to Kubernetes to federate with external identity providers. This approach is simpler to use and deploy, and overcomes several limitations in <a href="https://github.com/Azure/aad-pod-identity">Azure AD Pod Identity</a>:</p>
<ul>
<li>Removes the scale and performance issues that existed for identity assignment</li>
<li>Supports Kubernetes clusters hosted in <strong>any cloud</strong> or <strong>on-premises</strong></li>
<li>Supports both <strong>Linux</strong> and <strong>Windows</strong> workloads</li>
<li>Removes the need for Custom Resource Definitions and pods that intercept <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=windows">Instance Metadata Service (IMDS)</a> traffic</li>
<li>Avoids the complication and error-prone installation steps such as cluster role assignment from the previous iteration.</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<ul>
<li><a href="./installation.html">Installation</a>
<ul>
<li><a href="./installation/managed-clusters.html">Managed clusters</a> or <a href="./installation/self-managed-clusters.html">self-managed clusters</a></li>
<li><a href="./installation/mutating-admission-webhook.html">Mutating admission webhook</a></li>
<li><a href="./installation/azwi.html">Azure AD Workload Identity CLI (<code>azwi</code>)</a></li>
</ul>
</li>
<li><a href="./quick-start.html">Quick start</a></li>
<li><a href="./concepts.html">Concepts</a></li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>In this model, the Kubernetes cluster becomes a token issuer, issuing tokens to Kubernetes Service Accounts. These service account tokens can be configured to be trusted on Azure AD applications or user-assigned managed identities. Workload can exchange a service account token projected to its volume for an Azure AD access token using the Azure Identity SDKs or the Microsoft Authentication Library (MSAL).</p>
<!-- source
```mermaid
sequenceDiagram
    participant Kubelet
    participant Workload
    participant Azure Active Directory
    participant OpenID Discovery Document
    participant Azure Resources
    Kubelet->>Workload: Projects service account token <br> to the workload at a configurable <br> file path
    Workload->>Azure Active Directory: Sends projected, signed <br> service account token and requests <br> Azure AD access token
    Azure Active Directory->>OpenID Discovery Document: Checks trust on the identity <br> and validates incoming token
    Azure Active Directory->>Workload: Issues Azure AD access token
    Workload->>Azure Resources: Access resources using Azure AD access token
```
--->
<p><img src="./images/how-it-works-diagram.png" alt="How it works" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<ul>
<li><a href="installation.html#prerequisites">Prerequisites</a></li>
<li><a href="installation.html#azure-ad-workload-identity-components">Azure AD Workload Identity Components</a></li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli">Azure CLI</a> (≥2.32.0)
<ul>
<li>with <a href="https://github.com/Azure/azure-cli-extensions/tree/main/src/aks-preview">aks-preview</a> CLI extension installed (≥0.5.50)</li>
</ul>
</li>
<li><a href="https://helm.sh/docs/intro/install/">Helm 3</a></li>
<li>A Kubernetes cluster with version ≥ v1.20
<ul>
<li><strong>Follow the cluster-specific setup guide below before deploying Azure AD Workload Identity:</strong></li>
</ul>
</li>
</ul>
<table><thead><tr><th>Cluster type</th><th>Steps</th><th>Guide</th></tr></thead><tbody>
<tr><td>Managed cluster</td><td>1. Enable any OIDC-specific feature flags<br>2. Extract the OIDC issuer URL</td><td><a href="./installation/managed-clusters.html">Link</a></td></tr>
<tr><td>Self-managed cluster</td><td>1. Generate service account key pair or bring your own keys<br>2. Setup the public OIDC issuer URL<br>3. Generate OIDC discovery and JWKS documents<br>4. Configure <code>kube-apiserver</code> and <code>kube-controller-manager</code> flags</td><td><a href="./installation/self-managed-clusters.html">Link</a></td></tr>
</tbody></table>
<h2 id="azure-ad-workload-identity-components"><a class="header" href="#azure-ad-workload-identity-components">Azure AD Workload Identity Components</a></h2>
<table><thead><tr><th>Component</th><th>Description</th><th>Guide</th></tr></thead><tbody>
<tr><td>Mutating Admission Webhook</td><td>Projects a signed service account token to a well-known path (<code>/var/run/secrets/azure/tokens/azure-identity-token</code>) and inject authentication-related environment variables to your pods based on annotated service account.</td><td><a href="./installation/mutating-admission-webhook.html">Link</a></td></tr>
<tr><td>Azure AD Workload Identity CLI (<code>azwi</code>)</td><td>A utility CLI that helps manage Azure AD Workload Identity and automate error-prone operations.</td><td><a href="./installation/azwi.html">Link</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managed-clusters"><a class="header" href="#managed-clusters">Managed Clusters</a></h1>
<ul>
<li><a href="installation/managed-clusters.html#azure-kubernetes-service-aks">Azure Kubernetes Service (AKS)</a></li>
<li><a href="installation/managed-clusters.html#amazon-elastic-kubernetes-service-eks">Amazon Elastic Kubernetes Service (EKS)</a></li>
<li><a href="installation/managed-clusters.html#google-kubernetes-engine-gke">Google Kubernetes Engine (GKE)</a></li>
<li><a href="installation/managed-clusters.html#steps-to-get-the-oidc-issuer-url-from-a-generic-managed-cluster">Steps to get the OIDC issuer URL from a generic managed cluster</a>
<ul>
<li><a href="installation/managed-clusters.html#1-create-a-service-account-for-the-jump-pod">1. Create a service account for the jump pod</a></li>
<li><a href="installation/managed-clusters.html#2-deploy-a-jump-pod-referencing-the-service-account">2. Deploy a jump pod referencing the service account</a></li>
<li><a href="installation/managed-clusters.html#3-get-the-oidc-issuer-url-from-the-jump-pod">3. Get the OIDC issuer URL from the jump pod</a></li>
<li><a href="installation/managed-clusters.html#4-cleanup">4. Cleanup</a></li>
</ul>
</li>
</ul>
<p>For managed clusters, the service account signing keys will be set up and managed by the cloud provider.</p>
<p>Before deploying Azure AD Workload Identity, you will need to enable any <strong>OIDC-specific</strong> feature flags and obtain the <strong>OIDC issuer URL</strong> when setting up the federated identity credentials.</p>
<h2 id="azure-kubernetes-service-aks"><a class="header" href="#azure-kubernetes-service-aks">Azure Kubernetes Service (AKS)</a></h2>
<p>To create a new AKS cluster with OIDC Issuer URL enabled or update an existing cluster, follow the instructions in the <a href="https://learn.microsoft.com/en-us/azure/aks/use-oidc-issuer">Azure Kubernetes Service (AKS) documentation</a>.</p>
<p>To get your cluster’s OIDC issuer URL run:</p>
<pre><code class="language-bash"># Output the OIDC issuer URL
az aks show --resource-group &lt;resource_group&gt; --name &lt;cluster_name&gt; --query &quot;oidcIssuerProfile.issuerUrl&quot; -otsv
</code></pre>
<h2 id="amazon-elastic-kubernetes-service-eks"><a class="header" href="#amazon-elastic-kubernetes-service-eks">Amazon Elastic Kubernetes Service (EKS)</a></h2>
<p>EKS cluster has an OIDC issuer URL associated with it by default. To get your cluster’s OIDC issuer URL run:</p>
<pre><code class="language-bash"># Output the OIDC issuer URL
aws eks describe-cluster --name &lt;cluster_name&gt; --query &quot;cluster.identity.oidc.issuer&quot; --output text
</code></pre>
<p>Refer to the <a href="https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html">Amazon EKS documentation</a> for more information on the OIDC issuer URL for the EKS cluster.</p>
<h2 id="google-kubernetes-engine-gke"><a class="header" href="#google-kubernetes-engine-gke">Google Kubernetes Engine (GKE)</a></h2>
<p>GKE cluster has an OIDC issuer URL associated with it by default. Follow the <a href="installation/managed-clusters.html#steps-to-get-the-oidc-issuer-url-from-a-generic-managed-cluster">steps</a> to get the OIDC issuer URL.</p>
<h2 id="steps-to-get-the-oidc-issuer-url-from-a-generic-managed-cluster"><a class="header" href="#steps-to-get-the-oidc-issuer-url-from-a-generic-managed-cluster">Steps to get the OIDC issuer URL from a generic managed cluster</a></h2>
<p>In this section, we will cover how to get the OIDC issuer URL from a generic managed cluster using a jump pod.</p>
<h3 id="1-create-a-service-account-for-the-jump-pod"><a class="header" href="#1-create-a-service-account-for-the-jump-pod">1. Create a service account for the jump pod</a></h3>
<p>Run the following commands to set up a service account for the jump pod:</p>
<pre><code class="language-bash">export NAMESPACE=&quot;default&quot;
export SERVICE_ACCOUNT_NAME=&quot;jump-pod-sa&quot;

kubectl create serviceaccount ${SERVICE_ACCOUNT_NAME} -n ${NAMESPACE}
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">serviceaccount/jump-pod-sa created
</code></pre>
</details>
<h3 id="2-deploy-a-jump-pod-referencing-the-service-account"><a class="header" href="#2-deploy-a-jump-pod-referencing-the-service-account">2. Deploy a jump pod referencing the service account</a></h3>
<p>Deploy a jump pod with <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection">projected service account token</a> to your cluster. The jump pod uses the <a href="https://smallstep.com/cli/">step-cli</a> docker image that is used for inspecting the service account token to retrieve the OIDC issuer URL.</p>
<pre><code class="language-bash">cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: jump
  namespace: ${NAMESPACE}
spec:
  containers:
  - image: smallstep/step-cli
    name: step-cli
    command:
    - /bin/sh
    - -c
    - cat /var/run/secrets/tokens/test-token | step crypto jwt inspect --insecure
    volumeMounts:
    - mountPath: /var/run/secrets/tokens
      name: test-token
  serviceAccountName: ${SERVICE_ACCOUNT_NAME}
  volumes:
  - name: test-token
    projected:
      sources:
      - serviceAccountToken:
          path: test-token
          expirationSeconds: 3600
          audience: test
EOF
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">pod/jump created
</code></pre>
</details>
<h3 id="3-get-the-oidc-issuer-url-from-the-jump-pod"><a class="header" href="#3-get-the-oidc-issuer-url-from-the-jump-pod">3. Get the OIDC issuer URL from the jump pod</a></h3>
<p>The jump pod logs will contain the decoded JWT. Run the following command to get the logs and extract the OIDC issuer URL:</p>
<pre><code class="language-bash">kubectl logs jump -n ${NAMESPACE}
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-json">{
  &quot;header&quot;: {
    &quot;alg&quot;: &quot;RS256&quot;,
    &quot;kid&quot;: &quot;[REDACTED]&quot;
  },
  &quot;payload&quot;: {
    &quot;aud&quot;: [
      &quot;test&quot;
    ],
    &quot;exp&quot;: 1634671190,
    &quot;iat&quot;: 1634667590,
    &quot;iss&quot;: &quot;https://container.googleapis.com/v1/projects/[REDACTED]/locations/us-central1-c/clusters/[REDACTED]&quot;,
    &quot;kubernetes.io&quot;: {
      &quot;namespace&quot;: &quot;default&quot;,
      &quot;pod&quot;: {
        &quot;name&quot;: &quot;jump&quot;,
        &quot;uid&quot;: &quot;c4e09c90-3007-4255-ab74-f5f97d944db2&quot;
      },
      &quot;serviceaccount&quot;: {
        &quot;name&quot;: &quot;jump-pod-sa&quot;,
        &quot;uid&quot;: &quot;6af8dfb1-8a28-48f8-a7fe-e2abd99cd35e&quot;
      }
    },
    &quot;nbf&quot;: 1634667590,
    &quot;sub&quot;: &quot;system:serviceaccount:default:jump-pod-sa&quot;
  },
  &quot;signature&quot;: &quot;[REDACTED]&quot;
}
</code></pre>
</details>
<p>The OIDC issuer URL is the value of the <code>iss</code> claim in the JWT.</p>
<p>To just get the issuer from the JWT, run the following command:</p>
<pre><code class="language-bash">kubectl logs jump -n ${NAMESPACE} | jq -r '.payload.iss'
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-log">https://container.googleapis.com/v1/projects/[REDACTED]/locations/us-central1-c/clusters/[REDACTED]
</code></pre>
</details>
<h3 id="4-cleanup"><a class="header" href="#4-cleanup">4. Cleanup</a></h3>
<pre><code class="language-bash">kubectl delete pod jump -n ${NAMESPACE}
kubectl delete serviceaccount ${SERVICE_ACCOUNT_NAME} -n ${NAMESPACE}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-managed-clusters"><a class="header" href="#self-managed-clusters">Self-Managed Clusters</a></h1>
<p>When compared to using managed Kubernetes services like AKS, managing your own Kubernetes cluster provides the most freedom in customizing Kubernetes and your workload. However, there are additional setup required before deploying Azure AD Workload Identity to a self-managed cluster. If you are a cluster administrator, make sure you can perform the following actions:</p>
<ol>
<li><a href="installation/./self-managed-clusters/service-account-key-generation.html">Generate your own service account signing key pair</a> and <a href="installation/../topics/self-managed-clusters/service-account-key-rotation.html">rotate it regularly</a> (at least quarterly)</li>
<li>Manually set up your <a href="installation/./self-managed-clusters/oidc-issuer.html">OIDC issuer URL</a>, and upload your <a href="installation/./self-managed-clusters/oidc-issuer/discovery-document.html">discovery document</a> and <a href="installation/./self-managed-clusters/oidc-issuer/jwks.html">JWKS</a> to a public endpoint</li>
<li>Ability to <a href="installation/./self-managed-clusters/configurations.html">configure flags</a> for system-critical pods such as <code>kube-apiserver</code> and <code>kube-controller-manager</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-account-key-generation"><a class="header" href="#service-account-key-generation">Service Account Key Generation</a></h1>
<ul>
<li><a href="installation/self-managed-clusters/service-account-key-generation.html#walkthrough">Walkthrough</a>
<ul>
<li><a href="installation/self-managed-clusters/service-account-key-generation.html#1-generate-an-rsa-private-key-using-openssl">1. Generate an RSA private key using <code>openssl</code></a></li>
<li><a href="installation/self-managed-clusters/service-account-key-generation.html#2-generate-an-rsa-public-key-from-a-private-key-using-openssl">2. Generate an RSA public key from a private key using <code>openssl</code></a></li>
</ul>
</li>
</ul>
<p>There are two keys in an RSA key pair: a private key and a public key. The RSA private key is used to generate the digital signature and the RSA public key is used to verify them. In the case of service account tokens, they are signed by your private key/signing key before being projected to your workload’s volume. Azure Active Directory will then use your public key to verify the signature and ensure that the service account tokens are not malicious.</p>
<p>This section will show you how to generate an RSA key pair using <code>openssl</code>.</p>
<blockquote>
<p>Feel free to skip this section if you are planning to bring your own keys.</p>
</blockquote>
<h2 id="walkthrough"><a class="header" href="#walkthrough">Walkthrough</a></h2>
<h3 id="1-generate-an-rsa-private-key-using-openssl"><a class="header" href="#1-generate-an-rsa-private-key-using-openssl">1. Generate an RSA private key using <code>openssl</code></a></h3>
<pre><code class="language-bash">openssl genrsa -out sa.key 2048
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">Generating RSA private key, 2048 bit long modulus
.............................................+++
.......+++
e is 65537 (0x10001)
</code></pre>
</details>
<h3 id="2-generate-an-rsa-public-key-from-a-private-key-using-openssl"><a class="header" href="#2-generate-an-rsa-public-key-from-a-private-key-using-openssl">2. Generate an RSA public key from a private key using <code>openssl</code></a></h3>
<pre><code class="language-bash">openssl rsa -in sa.key -pubout -out sa.pub
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openid-connect-issuer"><a class="header" href="#openid-connect-issuer">OpenID Connect Issuer</a></h1>
<p>With the Kubernetes cluster acting as a token issuer, Azure Active Directory (AAD) leverages OpenID Connect (OIDC) to discover public signing keys and verify the authenticity of the service account token before exchanging it for an AAD token. Your workload can then consume the AAD token to access Azure cloud resources via the Azure Identity SDKs or the Microsoft Authentication Library (MSAL).</p>
<p>In the case of self-managed clusters, administrator will have to manually publish the cluster’s service account issuer URL, which should comply with the <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID specification</a>. The following table describes the required OIDC issuer endpoints for Azure AD Workload Identity:</p>
<table><thead><tr><th>Endpoint</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="installation/self-managed-clusters/./oidc-issuer/discovery-document.html"><code>{IssuerURL}/.well-known/openid-configuration</code></a></td><td>Also known as the OIDC discovery document. This contains the metadata about the issuer’s configurations.</td></tr>
<tr><td><a href="installation/self-managed-clusters/./oidc-issuer/jwks.html"><code>{IssuerURL}/openid/v1/jwks</code></a></td><td>This contains the public signing key(s) that AAD uses to verify the authenticity of the service account token.</td></tr>
</tbody></table>
<h2 id="sequence-diagram"><a class="header" href="#sequence-diagram">Sequence Diagram</a></h2>
<!-- source
```mermaid
sequenceDiagram
    participant Kubernetes Workload
    participant Azure Active Directory
    participant OpenID Connect Issuer
    Kubernetes Workload->>Azure Active Directory:Projected, signed service account token
    Azure Active Directory->>Azure Active Directory:Extract the issuer URL from the token request
    Azure Active Directory->>OpenID Connect Issuer:{IssuerURL}/.well-known/openid-configuration
    OpenID Connect Issuer->>Azure Active Directory:Return the discovery document
    Azure Active Directory->>Azure Active Directory:Extract the JWKS URL from the discovery document
    Azure Active Directory->>OpenID Connect Issuer:{IssuerURL}/openid/v1/jwks
    OpenID Connect Issuer->>Azure Active Directory:Return the JWKS document
    Azure Active Directory->>Azure Active Directory:Validate the authenticity of the service account token
    Azure Active Directory->>Kubernetes Workload:Return an AAD token
```
--->
<p><img src="installation/self-managed-clusters/../../images/oidc-issuer-sequence-diagram.png" alt="Sequence Diagram" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discovery-document"><a class="header" href="#discovery-document">Discovery Document</a></h1>
<ul>
<li><a href="installation/self-managed-clusters/oidc-issuer/discovery-document.html#walkthrough">Walkthrough</a>
<ul>
<li><a href="installation/self-managed-clusters/oidc-issuer/discovery-document.html#1-create-an-azure-blob-storage-account">1. Create an Azure Blob storage account</a></li>
<li><a href="installation/self-managed-clusters/oidc-issuer/discovery-document.html#2-generate-the-discovery-document">2. Generate the discovery document</a></li>
<li><a href="installation/self-managed-clusters/oidc-issuer/discovery-document.html#3-upload-the-discovery-document">3. Upload the discovery document</a></li>
<li><a href="installation/self-managed-clusters/oidc-issuer/discovery-document.html#4-verify-that-the-discovery-document-is-publicly-accessible">4. Verify that the discovery document is publicly accessible</a></li>
</ul>
</li>
</ul>
<p>OpenID Connect describes a <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">metadata document</a> that contains the metadata of the issuer. This includes information such as the URLs to use and the location of the service’s public signing keys. The following section will walk you through how to set up a secured, public OIDC issuer URL using Azure blob storage and upload a minimal discovery document to the storage account.</p>
<h2 id="walkthrough-1"><a class="header" href="#walkthrough-1">Walkthrough</a></h2>
<h3 id="1-create-an-azure-blob-storage-account"><a class="header" href="#1-create-an-azure-blob-storage-account">1. Create an Azure Blob storage account</a></h3>
<pre><code class="language-bash">export RESOURCE_GROUP=&quot;oidc-issuer&quot;
export LOCATION=&quot;westus2&quot;
az group create --name &quot;${RESOURCE_GROUP}&quot; --location &quot;${LOCATION}&quot;

export AZURE_STORAGE_ACCOUNT=&quot;oidcissuer$(openssl rand -hex 4)&quot;
export AZURE_STORAGE_CONTAINER=&quot;oidc-test&quot;
az storage account create --resource-group &quot;${RESOURCE_GROUP}&quot; --name &quot;${AZURE_STORAGE_ACCOUNT}&quot; --allow-blob-public-access true
az storage container create --name &quot;${AZURE_STORAGE_CONTAINER}&quot; --public-access blob
</code></pre>
<h3 id="2-generate-the-discovery-document"><a class="header" href="#2-generate-the-discovery-document">2. Generate the discovery document</a></h3>
<pre><code class="language-bash">cat &lt;&lt;EOF &gt; openid-configuration.json
{
  &quot;issuer&quot;: &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/&quot;,
  &quot;jwks_uri&quot;: &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/openid/v1/jwks&quot;,
  &quot;response_types_supported&quot;: [
    &quot;id_token&quot;
  ],
  &quot;subject_types_supported&quot;: [
    &quot;public&quot;
  ],
  &quot;id_token_signing_alg_values_supported&quot;: [
    &quot;RS256&quot;
  ]
}
EOF
</code></pre>
<h3 id="3-upload-the-discovery-document"><a class="header" href="#3-upload-the-discovery-document">3. Upload the discovery document</a></h3>
<pre><code class="language-bash">az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file openid-configuration.json \
  --name .well-known/openid-configuration
</code></pre>
<h3 id="4-verify-that-the-discovery-document-is-publicly-accessible"><a class="header" href="#4-verify-that-the-discovery-document-is-publicly-accessible">4. Verify that the discovery document is publicly accessible</a></h3>
<pre><code class="language-bash">curl -s &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/.well-known/openid-configuration&quot;
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-json">{
  &quot;issuer&quot;: &quot;https://&lt;REDACTED&gt;.blob.core.windows.net/oidc-test/&quot;,
  &quot;jwks_uri&quot;: &quot;https://&lt;REDACTED&gt;.blob.core.windows.net/oidc-test/openid/v1/jwks&quot;,
  &quot;response_types_supported&quot;: [
    &quot;id_token&quot;
  ],
  &quot;subject_types_supported&quot;: [
    &quot;public&quot;
  ],
  &quot;id_token_signing_alg_values_supported&quot;: [
    &quot;RS256&quot;
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-web-key-sets-jwks"><a class="header" href="#json-web-key-sets-jwks">JSON Web Key Sets (JWKS)</a></h1>
<ul>
<li><a href="installation/self-managed-clusters/oidc-issuer/jwks.html#walkthrough">Walkthrough</a>
<ul>
<li><a href="installation/self-managed-clusters/oidc-issuer/jwks.html#1-install-azwi">1. Install <code>azwi</code></a></li>
<li><a href="installation/self-managed-clusters/oidc-issuer/jwks.html#2-generate-the-jwks-document">2. Generate the JWKS document</a></li>
<li><a href="installation/self-managed-clusters/oidc-issuer/jwks.html#3-upload-the-jwks-document">3. Upload the JWKS document</a></li>
<li><a href="installation/self-managed-clusters/oidc-issuer/jwks.html#4-verify-that-the-jwks-document-is-publicly-accessible">4. Verify that the JWKS document is publicly accessible</a></li>
</ul>
</li>
</ul>
<p>The JSON Web Key Sets (JWKS) document contains the public signing key(s) that allows AAD to verify the authenticity of the service account token.</p>
<h2 id="walkthrough-2"><a class="header" href="#walkthrough-2">Walkthrough</a></h2>
<blockquote>
<p>Assuming you have access to your service account signing key pair and followed <a href="installation/self-managed-clusters/oidc-issuer/./discovery-document.html">the guide</a> on how to create and upload the discovery document to an Azure blob storage account. See <a href="installation/self-managed-clusters/oidc-issuer/../service-account-key-generation.html">this section</a> on how to generate a minimal signing key pair.</p>
</blockquote>
<h3 id="1-install-azwi"><a class="header" href="#1-install-azwi">1. Install <code>azwi</code></a></h3>
<p><a href="installation/self-managed-clusters/oidc-issuer/../../azwi.html">Installation guide</a></p>
<h3 id="2-generate-the-jwks-document"><a class="header" href="#2-generate-the-jwks-document">2. Generate the JWKS document</a></h3>
<pre><code class="language-bash">azwi jwks --public-keys &lt;PublicKeyPath&gt; --output-file jwks.json
</code></pre>
<blockquote>
<p>If you have multiple public signing keys, you can append additional <code>--public-keys</code> flag to the command.</p>
</blockquote>
<h3 id="3-upload-the-jwks-document"><a class="header" href="#3-upload-the-jwks-document">3. Upload the JWKS document</a></h3>
<pre><code class="language-bash">az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file jwks.json \
  --name openid/v1/jwks
</code></pre>
<h3 id="4-verify-that-the-jwks-document-is-publicly-accessible"><a class="header" href="#4-verify-that-the-jwks-document-is-publicly-accessible">4. Verify that the JWKS document is publicly accessible</a></h3>
<pre><code class="language-bash">curl -s &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/openid/v1/jwks&quot;
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-json">{
  &quot;keys&quot;: [
    {
      &quot;use&quot;: &quot;sig&quot;,
      &quot;kty&quot;: &quot;RSA&quot;,
      &quot;kid&quot;: &quot;Me5VC6i4_4mymFj7T5rcUftFjYX70YoCfSnZB6-nBY4&quot;,
      &quot;alg&quot;: &quot;RS256&quot;,
      &quot;n&quot;: &quot;ywg7HeKIFX3vleVKZHeYoNpuLHIDisnczYXrUdIGCNilCJFA1ymjG2UAADnt_FpYUsCVyKYJTqcxNbK4boNg_P3uK39OAqXabwYrilEZvsVJQKhzn8dXLeqAnM98L8eBpySU208KTsfMkS3Q6lqwurUP7c_a3g_1XRJukz_EmQxg9jLD_fQd5VwPTEo8HJQIFqIxFWzjTkkK5hbcL9Cclkf6RpeRyjh7Vem57Fu-jAlxDUiYiqyieM4OBNm4CQjiqDE8_xOC8viNpHNw542MYVDKSRnYui31lCOj32wBDphczR8BbnrZgbqN3K_zzB3gIjcGbWbbGA5xKJYqSu5uRwN89_CWrT3vGw5RN3XQPSbhGC4smgZkOCw3N9i1b-x-rrd-mRse6F95ONaoslCJUbJvxvDdb5X0P4_CVZRwJvUyP3OJ44ZvwzshA-zilG-QC9E1j2R9DTSMqOJzUuOxS0JIvoboteI1FAByV9KyU948zQRM7r7MMZYBKWIsu6h7&quot;,
      &quot;e&quot;: &quot;AQAB&quot;
    }
  ]
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configurations"><a class="header" href="#configurations">Configurations</a></h1>
<p>The following configurations are required to be enabled/set in the cluster configuration for Azure AD Workload Identity to function properly.</p>
<ul>
<li><a href="installation/self-managed-clusters/configurations.html#kube-apiserver-flags">kube-apiserver flags</a>
<ul>
<li><a href="installation/self-managed-clusters/configurations.html#--service-account-issuer"><code>--service-account-issuer</code></a></li>
<li><a href="installation/self-managed-clusters/configurations.html#--service-account-signing-key-file"><code>--service-account-signing-key-file</code></a></li>
<li><a href="installation/self-managed-clusters/configurations.html#--service-account-key-file"><code>--service-account-key-file</code></a></li>
</ul>
</li>
<li><a href="installation/self-managed-clusters/configurations.html#kube-controller-manager-flags">kube-controller-manager flags</a>
<ul>
<li><a href="installation/self-managed-clusters/configurations.html#--service-account-private-key-file"><code>--service-account-private-key-file</code></a></li>
</ul>
</li>
<li><a href="installation/self-managed-clusters/configurations.html#feature-flags">Feature Flags</a>
<ul>
<li><a href="installation/self-managed-clusters/configurations.html#service-account-token-volume-projection">Service Account Token Volume Projection</a></li>
</ul>
</li>
</ul>
<h2 id="kube-apiserver-flags"><a class="header" href="#kube-apiserver-flags">kube-apiserver flags</a></h2>
<p>This a list of required flags that need to be configured in the <code>kube-apiserver</code>. Refer to <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a> for more available flags.</p>
<h3 id="--service-account-issuer"><a class="header" href="#--service-account-issuer"><code>--service-account-issuer</code></a></h3>
<p>Identifier of the service account token issuer. The issuer will assert this identifier in “iss” claim of issued tokens. This value is a string or URI. If this option is not a valid URI per the OpenID Discovery 1.0 spec, the ServiceAccountIssuerDiscovery feature will remain disabled, even if the feature gate is set to true. It is highly recommended that this value comply with the OpenID spec: https://openid.net/specs/openid-connect-discovery-1_0.html. In practice, this means that service-account-issuer must be an https URL. It is also highly recommended that this URL be capable of serving OpenID discovery documents at {service-account-issuer}/.well-known/openid-configuration. When this flag is specified multiple times, the first is used to generate tokens and all are used to determine which issuers are accepted.</p>
<h3 id="--service-account-signing-key-file"><a class="header" href="#--service-account-signing-key-file"><code>--service-account-signing-key-file</code></a></h3>
<p>Path to the file that contains the current private key of the service account token issuer. The issuer will sign issued ID tokens with this private key.</p>
<h3 id="--service-account-key-file"><a class="header" href="#--service-account-key-file"><code>--service-account-key-file</code></a></h3>
<p>File containing PEM-encoded x509 RSA or ECDSA private or public keys, used to verify ServiceAccount tokens. The specified file can contain multiple keys, and the flag can be specified multiple times with different files. If unspecified, --tls-private-key-file is used. Must be specified when --service-account-signing-key is provided</p>
<h2 id="kube-controller-manager-flags"><a class="header" href="#kube-controller-manager-flags">kube-controller-manager flags</a></h2>
<p>This is a list of required flags that need to be configured in the <code>kube-controller-manager</code>. Refer to <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/">kube-controller-manager</a> for more available flags.</p>
<h3 id="--service-account-private-key-file"><a class="header" href="#--service-account-private-key-file"><code>--service-account-private-key-file</code></a></h3>
<p>Filename containing a PEM-encoded private RSA or ECDSA key used to sign service account tokens.</p>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<h3 id="service-account-token-volume-projection"><a class="header" href="#service-account-token-volume-projection">Service Account Token Volume Projection</a></h3>
<p>This feature is stable in Kubernetes v1.20 and is enabled by default. Refer to <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection">Service Account Token Volume Projection</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutating-admission-webhook"><a class="header" href="#mutating-admission-webhook">Mutating Admission Webhook</a></h1>
<ul>
<li><a href="installation/mutating-admission-webhook.html#prerequisites">Prerequisites</a></li>
<li><a href="installation/mutating-admission-webhook.html#helm-3-recommended">Helm 3 (Recommended)</a></li>
<li><a href="installation/mutating-admission-webhook.html#deployment-yaml">Deployment YAML</a>
<ul>
<li><a href="installation/mutating-admission-webhook.html#install-envsubst">Install <code>envsubst</code></a></li>
</ul>
</li>
</ul>
<p>Azure AD Workload Identity uses a <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">mutating admission webhook</a> to project a signed service account token to your workload’s volume and inject the following properties to pods with a service account that is configured to use the webhook:</p>
<details>
<summary>Properties</summary>
<table><thead><tr><th>Environment variable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AZURE_AUTHORITY_HOST</code></td><td>The Azure Active Directory (AAD) endpoint.</td></tr>
<tr><td><code>AZURE_CLIENT_ID</code></td><td>The application/client ID of the Azure AD application or user-assigned managed identity.</td></tr>
<tr><td><code>AZURE_TENANT_ID</code></td><td>The tenant ID of the Azure subscription.</td></tr>
<tr><td><code>AZURE_FEDERATED_TOKEN_FILE</code></td><td>The path of the projected service account token file.</td></tr>
</tbody></table>
<table><thead><tr><th>Volume</th><th>Description</th></tr></thead><tbody>
<tr><td><code>azure-identity-token</code></td><td>The projected service account volume.</td></tr>
</tbody></table>
<table><thead><tr><th>Volume mount</th><th>Description</th></tr></thead><tbody>
<tr><td><code>/var/run/secrets/azure/tokens/azure-identity-token</code></td><td>The path of the projected service account token file.</td></tr>
</tbody></table>
</details>
<p>The webhook allows pods to use a <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection">service account token</a> projected to a well-known volume path to exchange for an Azure AD access token by leveraging the above properties with the Azure Identity SDKs or the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-overview">Microsoft Authentication Library</a> (MSAL).</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Obtain your Azure tenant ID by running the following command:</p>
<pre><code class="language-bash">export AZURE_TENANT_ID=&quot;$(az account show -s &lt;AzureSubscriptionID&gt; --query tenantId -otsv)&quot;
</code></pre>
<p>The tenant ID above will be the default tenant ID that the webhook uses when configuring the <code>AZURE_TENANT_ID</code> environment variable in the pod. In the case of a multi-tenant cluster, you can override the tenant ID by adding the <code>azure.workload.identity/tenant-id</code> annotation to your service account.</p>
<p>You can install the mutating admission webhook with one of the following methods:</p>
<h2 id="helm-3-recommended"><a class="header" href="#helm-3-recommended">Helm 3 (Recommended)</a></h2>
<pre><code class="language-bash">helm repo add azure-workload-identity https://azure.github.io/azure-workload-identity/charts
helm repo update
helm install workload-identity-webhook azure-workload-identity/workload-identity-webhook \
   --namespace azure-workload-identity-system \
   --create-namespace \
   --set azureTenantID=&quot;${AZURE_TENANT_ID}&quot;
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">namespace/azure-workload-identity-system created
NAME: workload-identity-webhook
LAST DEPLOYED: Wed Aug  4 10:49:20 2021
NAMESPACE: azure-workload-identity-system
STATUS: deployed
REVISION: 1
TEST SUITE: None
</code></pre>
</details>
<h2 id="deployment-yaml"><a class="header" href="#deployment-yaml">Deployment YAML</a></h2>
<h3 id="install-envsubst"><a class="header" href="#install-envsubst">Install <code>envsubst</code></a></h3>
<p>The deployment YAML contains the environment variables we defined above and we rely on the <code>envsubst</code> binary to substitute them for their respective values before deploying. See <a href="https://github.com/a8m/envsubst#installation">the <code>envsubst</code>‘s installation guide</a> on how to install it.</p>
<p>Install the webhook using the deployment YAML via <code>kubectl apply -f</code> and <code>envsubst</code>:</p>
<pre><code class="language-bash">curl -sL https://github.com/Azure/azure-workload-identity/releases/download/v1.2.2/azure-wi-webhook.yaml | envsubst | kubectl apply -f -
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">namespace/azure-workload-identity-system created
serviceaccount/azure-wi-webhook-admin created
role.rbac.authorization.k8s.io/azure-wi-webhook-manager-role created
clusterrole.rbac.authorization.k8s.io/azure-wi-webhook-manager-role created
rolebinding.rbac.authorization.k8s.io/azure-wi-webhook-manager-rolebinding created
clusterrolebinding.rbac.authorization.k8s.io/azure-wi-webhook-manager-rolebinding created
configmap/azure-wi-webhook-config created
secret/azure-wi-webhook-server-cert created
service/azure-wi-webhook-webhook-service created
deployment.apps/azure-wi-webhook-controller-manager created
mutatingwebhookconfiguration.admissionregistration.k8s.io/azure-wi-webhook-mutating-webhook-configuration created
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="azure-ad-workload-cli-azwi"><a class="header" href="#azure-ad-workload-cli-azwi">Azure AD Workload CLI (azwi)</a></h1>
<p><code>azwi</code> is a utility CLI that helps manage Azure AD Workload Identity and automate error-prone operations:</p>
<ul>
<li>Generate the JWKS document from a list of public keys</li>
<li>Streamline the creation and deletion of the following resources:
<ul>
<li>AAD applications</li>
<li>Kubernetes service accounts</li>
<li>Federated identities</li>
<li>Azure role assignments</li>
</ul>
</li>
</ul>
<h3 id="github-releases"><a class="header" href="#github-releases">GitHub Releases</a></h3>
<p>You can download <code>azwi</code> from our <a href="https://github.com/Azure/azure-workload-identity/releases">latest GitHub releases</a>.</p>
<h3 id="homebrew-macos-only"><a class="header" href="#homebrew-macos-only">Homebrew (MacOS only)</a></h3>
<pre><code class="language-bash">brew install Azure/azure-workload-identity/azwi
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<ul>
<li><a href="quick-start.html#1-complete-the-installation-guide">1. Complete the installation guide</a></li>
<li><a href="quick-start.html#2-export-environment-variables">2. Export environment variables</a></li>
<li><a href="quick-start.html#3-create-an-azure-key-vault-and-secret">3. Create an Azure Key Vault and secret</a></li>
<li><a href="quick-start.html#4-create-an-aad-application-or-user-assigned-managed-identity-and-grant-permissions-to-access-the-secret">4. Create an AAD application or user-assigned managed identity and grant permissions to access the secret</a></li>
<li><a href="quick-start.html#5-create-a-kubernetes-service-account">5. Create a Kubernetes service account</a></li>
<li><a href="quick-start.html#6-establish-federated-identity-credential-between-the-identity-and-the-service-account-issuer--subject">6. Establish federated identity credential between the identity and the service account issuer &amp; subject</a></li>
<li><a href="quick-start.html#7-deploy-workload">7. Deploy workload</a></li>
<li><a href="quick-start.html#8-cleanup">8. Cleanup</a></li>
</ul>
<p>In this tutorial, we will cover the basics of how to use the webhook to acquire an Azure AD token to access a secret in an <a href="https://azure.microsoft.com/services/key-vault/">Azure Key Vault</a>.</p>
<blockquote>
<p>While this tutorial shows a 1:1 mapping between a Kubernetes service account and an Azure AD identity, it is possible to map:</p>
<ol>
<li>Multiple Kubernetes service accounts to a single Azure AD identity. Refer to <a href="./faq.html#how-to-federate-multiple-kubernetes-service-accounts-with-a-single-identity">FAQ</a> for more details.</li>
<li>Multiple Azure AD identities to a single Kubernetes service account. Refer to <a href="./faq.html#how-to-federate-multiple-identities-with-a-kubernetes-service-account">FAQ</a> for more details.</li>
</ol>
</blockquote>
<p>Before we get started, ensure the following:</p>
<ul>
<li>Azure CLI version 2.40.0 or higher. Run <code>az --version</code> to verify.</li>
<li>You are logged in with the Azure CLI as a user.
<ul>
<li>If you are logged in with a Service Principal, ensure that it has the correct <a href="./known-issues.html#user-tried-to-log-in-to-a-device-from-a-platform-unknown-thats-currently-not-supported-through-conditional-access-policy">API permissions</a> enabled.</li>
</ul>
</li>
<li>Your logged in account must have sufficient permissions to create applications and service principals or user-assigned managed identities in Azure AD.</li>
</ul>
<h2 id="1-complete-the-installation-guide"><a class="header" href="#1-complete-the-installation-guide">1. Complete the installation guide</a></h2>
<p><a href="./installation.html">Installation guide</a>. At this point, you should have already:</p>
<ul>
<li>installed the mutating admission webhook</li>
<li>obtained your cluster’s OIDC issuer URL</li>
<li>[optional] installed the Azure AD Workload Identity CLI</li>
</ul>
<h2 id="2-export-environment-variables"><a class="header" href="#2-export-environment-variables">2. Export environment variables</a></h2>
<pre><code class="language-bash"># environment variables for the Azure Key Vault resource
export KEYVAULT_NAME=&quot;azwi-kv-$(openssl rand -hex 2)&quot;
export KEYVAULT_SECRET_NAME=&quot;my-secret&quot;
export RESOURCE_GROUP=&quot;azwi-quickstart-$(openssl rand -hex 2)&quot;
export LOCATION=&quot;westus2&quot;

# environment variables for the AAD application
# [OPTIONAL] Only set this if you're using a Azure AD Application as part of this tutorial
export APPLICATION_NAME=&quot;&lt;your application name&gt;&quot;

# environment variables for the user-assigned managed identity
# [OPTIONAL] Only set this if you're using a user-assigned managed identity as part of this tutorial
export USER_ASSIGNED_IDENTITY_NAME=&quot;&lt;your user-assigned managed identity name&gt;&quot;

# environment variables for the Kubernetes service account &amp; federated identity credential
export SERVICE_ACCOUNT_NAMESPACE=&quot;default&quot;
export SERVICE_ACCOUNT_NAME=&quot;workload-identity-sa&quot;
export SERVICE_ACCOUNT_ISSUER=&quot;&lt;your service account issuer url&gt;&quot; # see section 1.1 on how to get the service account issuer url
</code></pre>
<h2 id="3-create-an-azure-key-vault-and-secret"><a class="header" href="#3-create-an-azure-key-vault-and-secret">3. Create an Azure Key Vault and secret</a></h2>
<p>Create an Azure resource group:</p>
<pre><code class="language-bash">az group create --name &quot;${RESOURCE_GROUP}&quot; --location &quot;${LOCATION}&quot;
</code></pre>
<p>Create an Azure Key Vault:</p>
<pre><code class="language-bash">az keyvault create --resource-group &quot;${RESOURCE_GROUP}&quot; \
   --location &quot;${LOCATION}&quot; \
   --name &quot;${KEYVAULT_NAME}&quot;
</code></pre>
<p>Create a secret:</p>
<pre><code class="language-bash">az keyvault secret set --vault-name &quot;${KEYVAULT_NAME}&quot; \
   --name &quot;${KEYVAULT_SECRET_NAME}&quot; \
   --value &quot;Hello\!&quot;
</code></pre>
<h2 id="4-create-an-aad-application-or-user-assigned-managed-identity-and-grant-permissions-to-access-the-secret"><a class="header" href="#4-create-an-aad-application-or-user-assigned-managed-identity-and-grant-permissions-to-access-the-secret">4. Create an AAD application or user-assigned managed identity and grant permissions to access the secret</a></h2>
<details>
<summary>Azure Workload Identity CLI</summary>
<blockquote>
<p>NOTE: <code>azwi</code> currently only supports Azure AD Applications. If you want to use a user-assigned managed identity, skip this section and follow the steps in the Azure CLI section.</p>
</blockquote>
<pre><code class="language-bash">azwi serviceaccount create phase app --aad-application-name &quot;${APPLICATION_NAME}&quot;
</code></pre>
<details>
<summary>Output</summary>
<pre><code>INFO[0000] No subscription provided, using selected subscription from Azure CLI: REDACTED
INFO[0005] [aad-application] created an AAD application  clientID=REDACTED name=azwi-test objectID=REDACTED
WARN[0005] --service-principal-name not specified, falling back to AAD application name
INFO[0005] [aad-application] created service principal   clientID=REDACTED name=azwi-test objectID=REDACTED
</code></pre>
</details>
</details>
<br>
<details>
<summary>Azure CLI</summary>
<pre><code class="language-bash"># create an AAD application if using Azure AD Application for this tutorial
az ad sp create-for-rbac --name &quot;${APPLICATION_NAME}&quot;
</code></pre>
<pre><code class="language-bash"># create a user-assigned managed identity if using user-assigned managed identity for this tutorial
az identity create --name &quot;${USER_ASSIGNED_IDENTITY_NAME}&quot; --resource-group &quot;${RESOURCE_GROUP}&quot;
</code></pre>
</details>
<p>Set access policy for the AAD application or user-assigned managed identity to access the keyvault secret:</p>
<p>If using Azure AD Application:</p>
<pre><code class="language-bash">export APPLICATION_CLIENT_ID=&quot;$(az ad sp list --display-name &quot;${APPLICATION_NAME}&quot; --query '[0].appId' -otsv)&quot;
az keyvault set-policy --name &quot;${KEYVAULT_NAME}&quot; \
  --secret-permissions get \
  --spn &quot;${APPLICATION_CLIENT_ID}&quot;
</code></pre>
<p>if using user-assigned managed identity:</p>
<pre><code class="language-bash">export USER_ASSIGNED_IDENTITY_CLIENT_ID=&quot;$(az identity show --name &quot;${USER_ASSIGNED_IDENTITY_NAME}&quot; --resource-group &quot;${RESOURCE_GROUP}&quot; --query 'clientId' -otsv)&quot;
export USER_ASSIGNED_IDENTITY_OBJECT_ID=&quot;$(az identity show --name &quot;${USER_ASSIGNED_IDENTITY_NAME}&quot; --resource-group &quot;${RESOURCE_GROUP}&quot; --query 'principalId' -otsv)&quot;
az keyvault set-policy --name &quot;${KEYVAULT_NAME}&quot; \
  --secret-permissions get \
  --object-id &quot;${USER_ASSIGNED_IDENTITY_OBJECT_ID}&quot;
</code></pre>
<h2 id="5-create-a-kubernetes-service-account"><a class="header" href="#5-create-a-kubernetes-service-account">5. Create a Kubernetes service account</a></h2>
<p>Create a Kubernetes service account and annotate it with the client ID of the AAD application we created in step 4:</p>
<details>
<summary>Azure Workload Identity CLI</summary>
<blockquote>
<p>NOTE: <code>azwi</code> currently only supports Azure AD Applications. If you want to use a user-assigned managed identity, skip this section and follow the steps in the <code>kubectl</code> section.</p>
</blockquote>
<pre><code class="language-bash">azwi serviceaccount create phase sa \
  --aad-application-name &quot;${APPLICATION_NAME}&quot; \
  --service-account-namespace &quot;${SERVICE_ACCOUNT_NAMESPACE}&quot; \
  --service-account-name &quot;${SERVICE_ACCOUNT_NAME}&quot;
</code></pre>
<details>
<summary>Output</summary>
<pre><code>INFO[0000] No subscription provided, using selected subscription from Azure CLI: REDACTED
INFO[0002] [service-account] created Kubernetes service account  name=workload-identity-sa namespace=default
</code></pre>
</details>
</details>
<br>
<details>
<summary>kubectl</summary>
<pre><code class="language-bash">cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    azure.workload.identity/client-id: ${APPLICATION_CLIENT_ID:-$USER_ASSIGNED_IDENTITY_CLIENT_ID}
  name: ${SERVICE_ACCOUNT_NAME}
  namespace: ${SERVICE_ACCOUNT_NAMESPACE}
EOF
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">serviceaccount/workload-identity-sa created
</code></pre>
</details>
</details>
<p>If the AAD application or user-assigned managed identity is not in the same tenant as the default tenant defined during installation, then annotate the service account with the application or user-assigned managed identity tenant ID:</p>
<pre><code class="language-bash">kubectl annotate sa ${SERVICE_ACCOUNT_NAME} -n ${SERVICE_ACCOUNT_NAMESPACE} azure.workload.identity/tenant-id=&quot;${APPLICATION_OR_USER_ASSIGNED_IDENTITY_TENANT_ID}&quot; --overwrite
</code></pre>
<h2 id="6-establish-federated-identity-credential-between-the-identity-and-the-service-account-issuer--subject"><a class="header" href="#6-establish-federated-identity-credential-between-the-identity-and-the-service-account-issuer--subject">6. Establish federated identity credential between the identity and the service account issuer &amp; subject</a></h2>
<details>
<summary>Azure Workload Identity CLI</summary>
<blockquote>
<p>NOTE: <code>azwi</code> currently only supports Azure AD Applications. If you want to use a user-assigned managed identity, skip this section and follow the steps in the <code>Azure CLI</code> section.</p>
</blockquote>
<pre><code class="language-bash">azwi serviceaccount create phase federated-identity \
  --aad-application-name &quot;${APPLICATION_NAME}&quot; \
  --service-account-namespace &quot;${SERVICE_ACCOUNT_NAMESPACE}&quot; \
  --service-account-name &quot;${SERVICE_ACCOUNT_NAME}&quot; \
  --service-account-issuer-url &quot;${SERVICE_ACCOUNT_ISSUER}&quot;
</code></pre>
<details>
<summary>Output</summary>
<pre><code>INFO[0000] No subscription provided, using selected subscription from Azure CLI: REDACTED
INFO[0032] [federated-identity] added federated credential  objectID=REDACTED subject=&quot;system:serviceaccount:default:workload-identity-sa&quot;
</code></pre>
</details>
</details>
<br>
<details>
<summary>Azure CLI</summary>
<p>If using Azure AD Application:</p>
<pre><code class="language-bash"># Get the object ID of the AAD application
export APPLICATION_OBJECT_ID=&quot;$(az ad app show --id ${APPLICATION_CLIENT_ID} --query id -otsv)&quot;
</code></pre>
<p>Add the federated identity credential:</p>
<pre><code class="language-bash">cat &lt;&lt;EOF &gt; params.json
{
  &quot;name&quot;: &quot;kubernetes-federated-credential&quot;,
  &quot;issuer&quot;: &quot;${SERVICE_ACCOUNT_ISSUER}&quot;,
  &quot;subject&quot;: &quot;system:serviceaccount:${SERVICE_ACCOUNT_NAMESPACE}:${SERVICE_ACCOUNT_NAME}&quot;,
  &quot;description&quot;: &quot;Kubernetes service account federated credential&quot;,
  &quot;audiences&quot;: [
    &quot;api://AzureADTokenExchange&quot;
  ]
}
EOF

az ad app federated-credential create --id ${APPLICATION_OBJECT_ID} --parameters @params.json
</code></pre>
<p>If using user-assigned managed identity:</p>
<pre><code class="language-bash">az identity federated-credential create \
  --name &quot;kubernetes-federated-credential&quot; \
  --identity-name &quot;${USER_ASSIGNED_IDENTITY_NAME}&quot; \
  --resource-group &quot;${RESOURCE_GROUP}&quot; \
  --issuer &quot;${SERVICE_ACCOUNT_ISSUER}&quot; \
  --subject &quot;system:serviceaccount:${SERVICE_ACCOUNT_NAMESPACE}:${SERVICE_ACCOUNT_NAME}&quot;
</code></pre>
</details>
<h2 id="7-deploy-workload"><a class="header" href="#7-deploy-workload">7. Deploy workload</a></h2>
<p>Deploy a pod that references the service account created in the last step:</p>
<pre><code class="language-bash">export KEYVAULT_URL=&quot;$(az keyvault show -g ${RESOURCE_GROUP} -n ${KEYVAULT_NAME} --query properties.vaultUri -o tsv)&quot;
cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: quick-start
  namespace: ${SERVICE_ACCOUNT_NAMESPACE}
  labels:
    azure.workload.identity/use: &quot;true&quot;
spec:
  serviceAccountName: ${SERVICE_ACCOUNT_NAME}
  containers:
    - image: ghcr.io/azure/azure-workload-identity/msal-go
      name: oidc
      env:
      - name: KEYVAULT_URL
        value: ${KEYVAULT_URL}
      - name: SECRET_NAME
        value: ${KEYVAULT_SECRET_NAME}
  nodeSelector:
    kubernetes.io/os: linux
EOF
</code></pre>
<p>Note: Newer version of the sample image will only need KEYVAULT_URL variable.</p>
<blockquote>
<p>Feel free to swap the msal-go example image above with a list of <a href="./topics/language-specific-examples/msal.html">language-specific examples</a> we provide.</p>
</blockquote>
<p>To check whether all properties are injected properly by the webhook:</p>
<pre><code class="language-bash">kubectl describe pod quick-start
</code></pre>
<details>
<summary>Output</summary>
<p>You can verify the following injected properties in the output:</p>
<table><thead><tr><th>Environment variable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AZURE_AUTHORITY_HOST</code></td><td>The Azure Active Directory (AAD) endpoint.</td></tr>
<tr><td><code>AZURE_CLIENT_ID</code></td><td>The client ID of the AAD application or user-assigned managed identity.</td></tr>
<tr><td><code>AZURE_TENANT_ID</code></td><td>The tenant ID of the registered AAD application or user-assigned managed identity.</td></tr>
<tr><td><code>AZURE_FEDERATED_TOKEN_FILE</code></td><td>The path of the projected service account token file.</td></tr>
</tbody></table>
<br/>
<table><thead><tr><th>Volume mount</th><th>Description</th></tr></thead><tbody>
<tr><td><code>/var/run/secrets/azure/tokens/azure-identity-token</code></td><td>The path of the projected service account token file.</td></tr>
</tbody></table>
<br/>
<table><thead><tr><th>Volume</th><th>Description</th></tr></thead><tbody>
<tr><td><code>azure-identity-token</code></td><td>The projected service account volume.</td></tr>
</tbody></table>
<pre><code class="language-log">Name:         quick-start
Namespace:    default
Priority:     0
Node:         k8s-agentpool1-38097163-vmss000002/10.240.0.34
Start Time:   Wed, 13 Oct 2021 15:49:25 -0700
Labels:       azure.workload.identity/use=true
Annotations:  &lt;none&gt;
Status:       Running
IP:           10.240.0.55
IPs:
  IP:  10.240.0.55
Containers:
  oidc:
    Container ID:   containerd://f425e89eef9aa3a62eb51a3daa5af8c06d8a59baa79c4e4dbb1887aea2647048
    Image:          ghcr.io/azure/azure-workload-identity/msal-go:latest
    Image ID:       ghcr.io/azure/azure-workload-identity/msal-go@sha256:84421aeea707ce66ade0891d9fcd3bb3f7bbd5dd3f810caced0acd315dcf8751
    Port:           &lt;none&gt;
    Host Port:      &lt;none&gt;
    State:          Running
      Started:      Wed, 13 Oct 2021 15:49:29 -0700
    Ready:          True
    Restart Count:  0
    Environment:
      KEYVAULT_URL:               ${KEYVAULT_URL}
      SECRET_NAME:                ${KEYVAULT_SECRET_NAME}
      AZURE_AUTHORITY_HOST:       (Injected by the webhook)
      AZURE_CLIENT_ID:            (Injected by the webhook)
      AZURE_TENANT_ID:            (Injected by the webhook)
      AZURE_FEDERATED_TOKEN_FILE: (Injected by the webhook)
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-844ns (ro)
      /var/run/secrets/azure/tokens from azure-identity-token (ro) (Injected by the webhook)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  kube-api-access-844ns:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             true
  azure-identity-token: (Injected by the webhook)
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3600
QoS Class:                   BestEffort
Node-Selectors:              kubernetes.io/os=linux
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  19s   default-scheduler  Successfully assigned oidc/quick-start to k8s-agentpool1-38097163-vmss000002
  Normal  Pulling    18s   kubelet            Pulling image &quot;ghcr.io/azure/azure-workload-identity/msal-go:latest&quot;
  Normal  Pulled     16s   kubelet            Successfully pulled image &quot;ghcr.io/azure/azure-workload-identity/msal-go:latest&quot; in 1.987165801s
  Normal  Created    15s   kubelet            Created container oidc
  Normal  Started    15s   kubelet            Started container oidc
</code></pre>
</details>
<p>To verify that pod is able to get a token and access the secret from the Key Vault:</p>
<pre><code class="language-bash">kubectl logs quick-start
</code></pre>
<details>
<summary>Output</summary>
<p>If successful, the log output would be similar to the following output:</p>
<pre><code class="language-bash">I1013 22:49:29.872708       1 main.go:30] &quot;successfully got secret&quot; secret=&quot;Hello!&quot;
</code></pre>
</details>
<h2 id="8-cleanup"><a class="header" href="#8-cleanup">8. Cleanup</a></h2>
<pre><code class="language-bash">kubectl delete pod quick-start
kubectl delete sa &quot;${SERVICE_ACCOUNT_NAME}&quot; --namespace &quot;${SERVICE_ACCOUNT_NAMESPACE}&quot;

az group delete --name &quot;${RESOURCE_GROUP}&quot;
# if you used Azure AD Application for tutorial, delete it by running the following command
az ad sp delete --id &quot;${APPLICATION_CLIENT_ID}&quot;
</code></pre>
<!-- markdown-link-check-disable-next-line -->
<!-- markdown-link-check-disable-next-line -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p><img src="./images/flow-diagram.png" alt="Flow Diagram" /></p>
<h2 id="service-account"><a class="header" href="#service-account">Service Account</a></h2>
<blockquote>
<p>“A service account provides an identity for processes that run in a Pod.” - <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">source</a></p>
</blockquote>
<p>Azure AD Workload Identity supports the following mappings:</p>
<ul>
<li>one-to-one (a service account referencing an AAD object)</li>
<li>many-to-one (multiple service accounts referencing the same AAD object).</li>
<li>one-to-many (a service account referencing multiple AAD objects by changing the <a href="./topics/service-account-labels-and-annotations.html#annotations">client ID annotation</a>).</li>
</ul>
<blockquote>
<p>Note: if the service account annotations are updated, you need to restart the pod for the changes to take effect.</p>
</blockquote>
<p>Users who used <a href="https://github.com/Azure/aad-pod-identity">aad-pod-identity</a> can think of a service account as an <a href="https://azure.github.io/aad-pod-identity/docs/concepts/azureidentity/">AzureIdentity</a>, except service account is part of the core Kubernetes API, rather than a CRD. This <a href="./topics/service-account-labels-and-annotations.html">doc</a> describes a list of available labels and annotations to configure.</p>
<h2 id="workload-identity-federation"><a class="header" href="#workload-identity-federation">Workload Identity Federation</a></h2>
<p>Using workload identity federation allows you to access Azure Active Directory (Azure AD) protected resources without needing to manage secrets. This <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/workload-identity-federation">doc</a> describes in detail on workload identity federation works and steps to create, delete, get or update federated identity credentials.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topics"><a class="header" href="#topics">Topics</a></h1>
<p>This section contains information about enabling and configuring various features with Azure AD Workload Identity. We strongly recommend users to go through each applicable topic in order, from setting up your Kubernetes clusters, performing various tasks for self-managed clusters, to leveraging the webhook in your application to securely access Azure cloud resources.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-account-labels-and-annotations"><a class="header" href="#service-account-labels-and-annotations">Service Account Labels and Annotations</a></h1>
<ul>
<li><a href="topics/service-account-labels-and-annotations.html#pod">Pod</a>
<ul>
<li><a href="topics/service-account-labels-and-annotations.html#labels">Labels</a></li>
<li><a href="topics/service-account-labels-and-annotations.html#annotations">Annotations</a></li>
</ul>
</li>
<li><a href="topics/service-account-labels-and-annotations.html#service-account">Service Account</a>
<ul>
<li><a href="topics/service-account-labels-and-annotations.html#annotations-1">Annotations</a></li>
</ul>
</li>
</ul>
<p>The following is a list of available labels and annotations that can be used to configure the behavior when exchanging the service account token for an AAD access token:</p>
<h2 id="pod"><a class="header" href="#pod">Pod</a></h2>
<h3 id="labels"><a class="header" href="#labels">Labels</a></h3>
<table><thead><tr><th>Label</th><th>Description</th><th>Recommended value</th><th>Required?</th></tr></thead><tbody>
<tr><td><code>azure.workload.identity/use</code></td><td>This label is <strong>required</strong> in the pod template spec. Only pods with this label will be mutated by the azure-workload-identity mutating admission webhook to inject the Azure specific environment variables and the projected service account token volume.</td><td><code>true</code></td><td>✓</td></tr>
</tbody></table>
<h3 id="annotations"><a class="header" href="#annotations">Annotations</a></h3>
<p>All annotations are optional. If the annotation is not specified, the default value will be used.</p>
<table><thead><tr><th>Annotation</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>azure.workload.identity/service-account-token-expiration</code></td><td><strong>(Takes precedence if the service account is also annotated)</strong> Represents the <code>expirationSeconds</code> field for the projected service account token. It is an optional field that the user might want to configure this to prevent any downtime caused by errors during service account token refresh. Kubernetes service account token expiry will not be correlated with AAD tokens. AAD tokens will expire in 24 hours after they are issued.</td><td><code>3600</code> (acceptable range: <code>3600 - 86400</code>)</td></tr>
<tr><td><code>azure.workload.identity/skip-containers</code></td><td>Represents a semi-colon-separated list of containers (e.g. <code>container1;container2</code>) to skip adding projected service account token volume. By default, the projected service account token volume will be added to all containers.</td><td></td></tr>
<tr><td><code>azure.workload.identity/inject-proxy-sidecar</code></td><td>Injects a proxy init container and proxy sidecar into the pod. The proxy sidecar is used to intercept token requests to IMDS and acquire an AAD token on behalf of the user with federated identity credential.</td><td><code>true</code></td></tr>
<tr><td><code>azure.workload.identity/proxy-sidecar-port</code></td><td>Represents the port of the proxy sidecar.</td><td><code>8000</code></td></tr>
</tbody></table>
<h2 id="service-account-1"><a class="header" href="#service-account-1">Service Account</a></h2>
<h3 id="annotations-1"><a class="header" href="#annotations-1">Annotations</a></h3>
<p>All annotations are optional. If the annotation is not specified, the default value will be used.</p>
<table><thead><tr><th>Annotation</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>azure.workload.identity/client-id</code></td><td>Represents the AAD application or user-assigned managed identity client ID to be used with the pod.</td><td></td></tr>
<tr><td><code>azure.workload.identity/tenant-id</code></td><td>Represents the Azure tenant ID where the AAD application or user-assigned managed identity is registered.</td><td><code>AZURE_TENANT_ID</code> environment variable extracted from <a href="https://github.com/Azure/azure-workload-identity/blob/40b3842dc49784bb014ad5d8b02cf6c959244196/deploy/azure-wi-webhook.yaml#L101-L110"><code>azure-wi-webhook-config</code></a> ConfigMap</td></tr>
<tr><td><code>azure.workload.identity/service-account-token-expiration</code></td><td>Represents the <code>expirationSeconds</code> field for the projected service account token. It is an optional field that the user might want to configure this to prevent any downtime caused by errors during service account token refresh. Kubernetes service account token expiry will not be correlated with AAD tokens. AAD tokens will expire in 24 hours after they are issued.</td><td><code>3600</code> (acceptable range: <code>3600 - 86400</code>)</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="federated-identity-credential"><a class="header" href="#federated-identity-credential">Federated Identity Credential</a></h1>
<ul>
<li><a href="topics/federated-identity-credential.html#azure-workload-identity-cli">Azure Workload Identity CLI</a></li>
<li><a href="topics/federated-identity-credential.html#azure-cli">Azure CLI</a>
<ul>
<li><a href="topics/federated-identity-credential.html#federated-identity-credential-for-an-azure-ad-application">Federated identity credential for an Azure AD application</a></li>
<li><a href="topics/federated-identity-credential.html#federated-identity-credential-for-a-user-assigned-managed-identity">Federated identity credential for a user-assigned managed identity</a></li>
</ul>
</li>
<li><a href="topics/federated-identity-credential.html#azure-portal-ui">Azure Portal UI</a>
<ul>
<li><a href="topics/federated-identity-credential.html#federated-identity-credential-for-an-azure-ad-application-1">Federated identity credential for an Azure AD application</a></li>
<li><a href="topics/federated-identity-credential.html#federated-identity-credential-for-a-user-assigned-managed-identity-1">Federated identity credential for a user-assigned managed identity</a></li>
</ul>
</li>
</ul>
<p>Not all service account tokens can be exchanged for a valid AAD token. A federated identity credential between an existing Kubernetes service account and an AAD application or user-assigned managed identity has to be created in advance. Refer to <a href="https://docs.microsoft.com/en-us/graph/api/resources/federatedidentitycredentials-overview?view=graph-rest-beta&amp;preserve-view=true">doc</a> for an overview of federated identity credentials in Azure Active Directory.</p>
<blockquote>
<p>NOTE: A maximum of <strong>20</strong> federated identity credentials can be added per AAD application or user-assigned managed identity object. The federated identity credentials API is not available in <a href="https://docs.microsoft.com/en-us/graph/deployments">national cloud deployments</a> - <a href="https://docs.microsoft.com/en-us/graph/api/resources/federatedidentitycredentials-overview?view=graph-rest-beta&amp;preserve-view=true">source</a></p>
</blockquote>
<p>Export the following environment variables:</p>
<pre><code class="language-bash">export SERVICE_ACCOUNT_NAMESPACE=&quot;...&quot;
export SERVICE_ACCOUNT_NAME=&quot;...&quot;
export SERVICE_ACCOUNT_ISSUER=&quot;...&quot; # see section 1.1 on how to get the service account issuer url

# if you are using a Azure AD application
export APPLICATION_NAME=&quot;&lt;your application name&gt;&quot;

# if you are using a user-assigned managed identity
export USER_ASSIGNED_MANAGED_IDENTITY_NAME=&quot;&lt;your user-assigned managed identity name&gt;&quot;
export RESOURCE_GROUP=&quot;&lt;your user-assigned managed identity resource group&gt;&quot;
</code></pre>
<p>Currently, there are several ways to create and delete a federated identity credential:</p>
<h2 id="azure-workload-identity-cli"><a class="header" href="#azure-workload-identity-cli">Azure Workload Identity CLI</a></h2>
<blockquote>
<p>NOTE: <code>azwi</code> currently only supports Azure AD Applications. If you want to use a user-assigned managed identity, skip this section and follow the steps in the Azure CLI section.</p>
</blockquote>
<p>To create a federated identity credential:</p>
<pre><code class="language-bash">azwi serviceaccount create phase federated-identity \
  --aad-application-name &quot;${APPLICATION_NAME}&quot; \
  --service-account-namespace &quot;${SERVICE_ACCOUNT_NAMESPACE}&quot; \
  --service-account-name &quot;${SERVICE_ACCOUNT_NAME}&quot; \
  --service-account-issuer-url &quot;${SERVICE_ACCOUNT_ISSUER}&quot;
</code></pre>
<p>To delete a federated identity credential:</p>
<pre><code class="language-bash">azwi serviceaccount delete phase federated-identity \
  --aad-application-name &quot;${APPLICATION_NAME}&quot; \
  --service-account-namespace &quot;${SERVICE_ACCOUNT_NAMESPACE}&quot; \
  --service-account-name &quot;${SERVICE_ACCOUNT_NAME}&quot; \
  --service-account-issuer-url &quot;${SERVICE_ACCOUNT_ISSUER}&quot;
</code></pre>
<h2 id="azure-cli"><a class="header" href="#azure-cli">Azure CLI</a></h2>
<p>A federated identity credential can also be created using the <code>az</code> CLI. This can either be done in a local terminal session, or using <a href="https://portal.azure.com/#cloudshell/">Azure Cloud Shell</a>. Use the <code>az</code> CLI to run the following commands:</p>
<h3 id="federated-identity-credential-for-an-azure-ad-application"><a class="header" href="#federated-identity-credential-for-an-azure-ad-application">Federated identity credential for an Azure AD application</a></h3>
<pre><code class="language-bash"># Get the object ID of the AAD application
export APPLICATION_OBJECT_ID=&quot;$(az ad app list --display-name &quot;${APPLICATION_NAME}&quot; --query '[0].id' -otsv)&quot;

cat &lt;&lt;EOF &gt; params.json
{
  &quot;name&quot;: &quot;kubernetes-federated-identity&quot;,
  &quot;issuer&quot;: &quot;${SERVICE_ACCOUNT_ISSUER}&quot;,
  &quot;subject&quot;: &quot;system:serviceaccount:${SERVICE_ACCOUNT_NAMESPACE}:${SERVICE_ACCOUNT_NAME}&quot;,
  &quot;description&quot;: &quot;Kubernetes service account federated identity&quot;,
  &quot;audiences&quot;: [
    &quot;api://AzureADTokenExchange&quot;
  ]
}
EOF

az ad app federated-credential create --id $APPLICATION_OBJECT_ID --parameters params.json
</code></pre>
<p>To delete a federated identity credential, the federated identity credential ID needs to be obtained with the following command:</p>
<pre><code class="language-bash">az ad app federated-credential list --id &quot;${APPLICATION_OBJECT_ID}&quot;
</code></pre>
<p>Select the desired ID of the federated identity credential and run the following command:</p>
<pre><code class="language-bash">az ad app federated-credential delete --federated-credential-id $FIC_ID --id $APPLICATION_OBJECT_ID
</code></pre>
<h3 id="federated-identity-credential-for-a-user-assigned-managed-identity"><a class="header" href="#federated-identity-credential-for-a-user-assigned-managed-identity">Federated identity credential for a user-assigned managed identity</a></h3>
<pre><code class="language-bash">az identity federated-credential create \
  --name &quot;kubernetes-federated-identity&quot; \
  --identity-name &quot;${USER_ASSIGNED_MANAGED_IDENTITY_NAME}&quot; \
  --resource-group &quot;${RESOURCE_GROUP}&quot; \
  --issuer &quot;${SERVICE_ACCOUNT_ISSUER}&quot; \
  --subject &quot;system:serviceaccount:${SERVICE_ACCOUNT_NAMESPACE}:${SERVICE_ACCOUNT_NAME}&quot;
</code></pre>
<p>To delete a federated identity credential </p>
<pre><code class="language-bash">az identity federated-credential delete \
  --identity-name &quot;${USER_ASSIGNED_MANAGED_IDENTITY_NAME}&quot; \
  --name &quot;kubernetes-federated-identity&quot; \
  --resource-group &quot;${RESOURCE_GROUP}&quot;
</code></pre>
<p>For more information on the <code>az identity federated-credential</code> command, refer to the <a href="https://learn.microsoft.com/en-us/cli/azure/identity/federated-credential?view=azure-cli-latest">Azure CLI documentation</a>.</p>
<h2 id="azure-portal-ui"><a class="header" href="#azure-portal-ui">Azure Portal UI</a></h2>
<h3 id="federated-identity-credential-for-an-azure-ad-application-1"><a class="header" href="#federated-identity-credential-for-an-azure-ad-application-1">Federated identity credential for an Azure AD application</a></h3>
<ol>
<li>Sign in to the <a href="https://portal.azure.com">Azure portal</a>. </li>
<li>Go to <strong>App registrations</strong> and open the app you want to configure.</li>
<li>Go to <strong>Certificates and secrets</strong>. </li>
<li>In the <strong>Federated credentials</strong> tab, select <strong>Add credential</strong>. The <strong>Add a credential</strong> blade opens.</li>
<li>In the <strong>Federated credential scenario</strong> drop-down box select <strong>Kubernetes accessing Azure resources</strong>.</li>
<li>Specify the <strong>Cluster issuer URL</strong>.</li>
<li>Specify the <strong>Namespace</strong>.</li>
<li>Specify the <strong>Service account name</strong>.</li>
<li>The <strong>Subject identifier</strong> field auto-populates based on the values you entered.</li>
<li>Add a <strong>Name</strong> for the federated credential.</li>
<li>Click <strong>Add</strong> to configure the federated credential.</li>
</ol>
<p><img src="topics/../images/azure-portal-federated-credential-kubernetes.png" alt="Screenshot showing Azure Portal app registration federated credential screen for Kubernetes scenario" /></p>
<h3 id="federated-identity-credential-for-a-user-assigned-managed-identity-1"><a class="header" href="#federated-identity-credential-for-a-user-assigned-managed-identity-1">Federated identity credential for a user-assigned managed identity</a></h3>
<ol>
<li>Sign in to the <a href="https://portal.azure.com">Azure portal</a>. </li>
<li>Go to resource group and open the user-assigned managed identity you want to configure.</li>
<li>Go to <strong>Federated credentials</strong>.</li>
<li>In the <strong>Federated credentials</strong> tab, select <strong>Add credential</strong>. The <strong>Add a credential</strong> blade opens.</li>
<li>In the <strong>Federated credential scenario</strong> drop-down box select <strong>Kubernetes accessing Azure resources</strong>.</li>
<li>Specify the <strong>Cluster issuer URL</strong>.</li>
<li>Specify the <strong>Namespace</strong>.</li>
<li>Specify the <strong>Service account name</strong>.</li>
<li>The <strong>Subject identifier</strong> field auto-populates based on the values you entered.</li>
<li>Add a <strong>Name</strong> for the federated credential.</li>
<li>Click <strong>Add</strong> to configure the federated credential.</li>
</ol>
<p><img src="topics/../images/azure-portal-mi-federated-credential.png" alt="Screenshot showing Azure Portal user-assigned managed identity federated credential screen for Kubernetes scenario" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="azure-workload-identity-cli-azwi"><a class="header" href="#azure-workload-identity-cli-azwi">Azure Workload Identity CLI (<code>azwi</code>)</a></h1>
<p>The Azure Workload Identity CLI (<code>azwi</code>) is a utility CLI that helps manage Azure AD Workload Identity and automate error-prone operations:</p>
<ul>
<li>Generate the JWKS document from a list of public keys</li>
<li>Streamline the creation and deletion of the following resources:
<ul>
<li>AAD applications</li>
<li>Kubernetes service accounts</li>
<li>Federated identities</li>
<li>Azure role assignments</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="azwi-serviceaccount-create"><a class="header" href="#azwi-serviceaccount-create"><code>azwi serviceaccount create</code></a></h1>
<p>Create a workload identity.</p>
<h2 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h2>
<p>The “create” command executes the following phases in order:</p>
<pre><code>aad-application     Create Azure Active Directory (AAD) application and its underlying service principal
service-account     Create Kubernetes service account in the current KUBECONFIG context and add azure-workload-identity labels and annotations to it
federated-identity  Create federated identity credential between the AAD application and the Kubernetes service account
role-assignment     Create role assignment between the AAD application and the Azure cloud resource
</code></pre>
<!---->
<pre><code>azwi serviceaccount create [flags]
</code></pre>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<pre><code>      --aad-application-client-id string            Client ID of the AAD application. If not specified, it will be fetched using the AAD application name
      --aad-application-name string                 Name of the AAD application, If not specified, the namespace, the name of the service account and the hash of the issuer URL will be used
      --aad-application-object-id string            Object ID of the AAD application. If not specified, it will be fetched using the AAD application name
      --auth-method string                          auth method to use. Supported values: cli, client_secret, client_certificate (default &quot;cli&quot;)
      --azure-env string                            the target Azure cloud (default &quot;AzurePublicCloud&quot;)
      --azure-role string                           Role of the AAD application (see all available roles at https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles)
      --azure-scope string                          Scope at which the role assignment or definition applies to
      --certificate-path string                     path to client certificate (used with --auth-method=client_certificate)
      --client-id string                            client id (used with --auth-method=[client_secret|client_certificate])
      --client-secret string                        client secret (used with --auth-method=client_secret)
  -h, --help                                        help for create
      --private-key-path string                     path to private key (used with --auth-method=client_certificate)
      --service-account-issuer-url string           URL of the issuer
      --service-account-name string                 Name of the service account
      --service-account-namespace string            Namespace of the service account (default &quot;default&quot;)
      --service-account-token-expiration duration   Expiration time of the service account token. Must be between 1 hour and 24 hours (default 1h0m0s)
      --service-principal-name string               Name of the service principal that backs the AAD application. If this is not specified, the name of the AAD application will be used
      --service-principal-object-id string          Object ID of the service principal that backs the AAD application. If not specified, it will be fetched using the service principal name
      --skip-phases strings                         List of phases to skip
  -s, --subscription-id string                      azure subscription id (required)
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-bash">az login &amp;&amp; az account set -s &lt;SubscriptionID&gt;
azwi serviceaccount create \
  --service-account-name azwi-sa \
  --service-account-issuer-url https://azwi.blob.core.windows.net/oidc-test/ \
  --skip-phases role-assignment
</code></pre>
<details>
<summary>Output</summary>
<pre><code>INFO[0000] No subscription provided, using selected subscription from Azure CLI: &lt;SubscriptionID&gt;
INFO[0003] skipping phase                                phase=role-assignment
INFO[0003] [aad-application] created an AAD application  clientID=936ed007-52c2-4785-8c09-04eeca2e5970 name=&quot;default-azwi-sa-1g7d7NgSw9Q2EsSeafgx8uQKqR4q6zTrsPjDdrvN79Y=&quot; objectID=19888f97-e0d3-4f61-8eb9-b87bf161e27d
INFO[0003] [aad-application] created service principal   clientID=936ed007-52c2-4785-8c09-04eeca2e5970 name=&quot;default-azwi-sa-1g7d7NgSw9Q2EsSeafgx8uQKqR4q6zTrsPjDdrvN79Y=&quot; objectID=4e3c51e5-ec74-40e2-8e28-2606803a048e
INFO[0003] [service-account] created Kubernetes service account  name=azwi-sa namespace=default
INFO[0004] [federated-identity] added federated credential  objectID=19888f97-e0d3-4f61-8eb9-b87bf161e27d subject=&quot;system:serviceaccount:default:azwi-sa&quot;
</code></pre>
</details>
<h2 id="invoke-a-single-phase-of-the-create-workflow"><a class="header" href="#invoke-a-single-phase-of-the-create-workflow">Invoke a single phase of the create workflow</a></h2>
<p>To invoke a single phase of the create workflow:</p>
<pre><code>azwi sa create phase &lt;phase name&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="azwi-serviceaccount-delete"><a class="header" href="#azwi-serviceaccount-delete"><code>azwi serviceaccount delete</code></a></h1>
<p>Delete a workload identity.</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1">Synopsis</a></h2>
<p>The “delete” command executes the following phases in order:</p>
<pre><code>role-assignment     Delete the role assignment between the AAD application and the Azure cloud resource
federated-identity  Delete federated identity credential for the AAD application and the Kubernetes service account
service-account     Delete the Kubernetes service account in the current KUBECONFIG context
aad-application     Delete the Azure Active Directory (AAD) application and its underlying service principal
</code></pre>
<!---->
<pre><code>azwi serviceaccount delete [flags]
</code></pre>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<pre><code>      --aad-application-name string         Name of the AAD application. If not specified, the namespace, the name of the service account and the hash of the issuer URL will be used
      --aad-application-object-id string    Object ID of the AAD application. If not specified, it will be fetched using the AAD application name
      --auth-method string                  auth method to use. Supported values: cli, client_secret, client_certificate (default &quot;cli&quot;)
      --azure-env string                    the target Azure cloud (default &quot;AzurePublicCloud&quot;)
      --certificate-path string             path to client certificate (used with --auth-method=client_certificate)
      --client-id string                    client id (used with --auth-method=[client_secret|client_certificate])
      --client-secret string                client secret (used with --auth-method=client_secret)
  -h, --help                                help for delete
      --private-key-path string             path to private key (used with --auth-method=client_certificate)
      --role-assignment-id string           Azure role assignment ID
      --service-account-issuer-url string   URL of the issuer
      --service-account-name string         Name of the service account
      --service-account-namespace string    Namespace of the service account (default &quot;default&quot;)
      --skip-phases strings                 List of phases to skip
  -s, --subscription-id string              azure subscription id (required)
</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-bash">az login &amp;&amp; az account set -s &lt;SubscriptionID&gt;
azwi sa delete \
  --service-account-name azwi-sa \
  --service-account-issuer-url https://azwi.blob.core.windows.net/oidc-test/ \
  --skip-phases role-assignment
</code></pre>
<details>
<summary>Output</summary>
<pre><code>INFO[0000] No subscription provided, using selected subscription from Azure CLI: &lt;SubscriptionID&gt;
INFO[0001] skipping phase                                phase=role-assignment
INFO[0001] [federated-identity] deleted federated identity credential  issuerURL=&quot;https://azwi.blob.core.windows.net/oidc-test/&quot; subject=&quot;system:serviceaccount:default:azwi-sa&quot;
INFO[0001] [service-account] deleted service account     name=azwi-sa namespace=default
INFO[0001] [aad-application] deleted aad application     objectID=19888f97-e0d3-4f61-8eb9-b87bf161e27d
</code></pre>
</details>
<h2 id="invoke-a-single-phase-of-the-delete-workflow"><a class="header" href="#invoke-a-single-phase-of-the-delete-workflow">Invoke a single phase of the delete workflow</a></h2>
<p>To invoke a single phase of the delete workflow:</p>
<pre><code>azwi sa delete phase &lt;phase name&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="azwi-jwks"><a class="header" href="#azwi-jwks"><code>azwi jwks</code></a></h1>
<p>Create JSON Web Key Sets for the service account issuer keys.</p>
<h2 id="synopsis-2"><a class="header" href="#synopsis-2">Synopsis</a></h2>
<p>This command provides the ability to generate the JSON Web Key Sets (JWKS) for the service account issuer keys</p>
<pre><code>azwi jwks [flags]
</code></pre>
<h2 id="options-2"><a class="header" href="#options-2">Options</a></h2>
<pre><code>  -h, --help                  help for jwks
      --output-file string    The name of the file to write the JWKS to. If not provided, the default output is stdout
      --public-keys strings   List of public keys to include in the JWKS
</code></pre>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-bash">azwi jwks --public-keys sa.pub
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-json">{
  &quot;keys&quot;: [
    {
      &quot;use&quot;: &quot;sig&quot;,
      &quot;kty&quot;: &quot;RSA&quot;,
      &quot;kid&quot;: &quot;Me5VC6i4_4mymFj7T5rcUftFjYX70YoCfSnZB6-nBY4&quot;,
      &quot;alg&quot;: &quot;RS256&quot;,
      &quot;n&quot;: &quot;ywg7HeKIFX3vleVKZHeYoNpuLHIDisnczYXrUdIGCNilCJFA1ymjG2UAADnt_FpYUsCVyKYJTqcxNbK4boNg_P3uK39OAqXabwYrilEZvsVJQKhzn8dXLeqAnM98L8eBpySU208KTsfMkS3Q6lqwurUP7c_a3g_1XRJukz_EmQxg9jLD_fQd5VwPTEo8HJQIFqIxFWzjTkkK5hbcL9Cclkf6RpeRyjh7Vem57Fu-jAlxDUiYiqyieM4OBNm4CQjiqDE8_xOC8viNpHNw542MYVDKSRnYui31lCOj32wBDphczR8BbnrZgbqN3K_zzB3gIjcGbWbbGA5xKJYqSu5uRwN89_CWrT3vGw5RN3XQPSbhGC4smgZkOCw3N9i1b-x-rrd-mRse6F95ONaoslCJUbJvxvDdb5X0P4_CVZRwJvUyP3OJ44ZvwzshA-zilG-QC9E1j2R9DTSMqOJzUuOxS0JIvoboteI1FAByV9KyU948zQRM7r7MMZYBKWIsu6h7&quot;,
      &quot;e&quot;: &quot;AQAB&quot;
    }
  ]
}
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-managed-clusters-1"><a class="header" href="#self-managed-clusters-1">Self-Managed Clusters</a></h1>
<p>The following sections contain the best practices when using Azure AD Workload Identity on a self-managed clusters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-account-key-rotation"><a class="header" href="#service-account-key-rotation">Service Account Key Rotation</a></h1>
<ul>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#best-practices">Best Practices</a>
<ul>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#key-rotation">Key rotation</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#key-retirement">Key retirement</a></li>
</ul>
</li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#steps-to-manually-generate-and-rotate-keys">Steps to manually generate and rotate keys</a>
<ul>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#1-generate-a-new-key-pair">1. Generate a new key pair</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#2-backup-the-old-key-pair-and-distribute-the-new-key-pair">2. Backup the old key pair and distribute the new key pair</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#3-update-the-jwks">3. Update the JWKS</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#4-key-rotation">4. Key Rotation</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#5-verification">5. Verification</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#6-cleanup">6. Cleanup</a></li>
<li><a href="topics/self-managed-clusters/service-account-key-rotation.html#7-remove-old-jwk-after-maximum-token-expiration">7. Remove old JWK after maximum token expiration</a></li>
</ul>
</li>
</ul>
<p>A security best practice is to routinely rotate your key pair used to sign the service account tokens. This page explains the best practices, guidelines, as well as how to generate and rotate it in the case of self-managed Kubernetes clusters where you have access to the control plane.</p>
<blockquote>
<p>This technique requires that the Kubernetes control plane is running in a high-availability (HA) setup with multiple API servers. Clusters that use a single API server will become unavailable while the API server is restarted.</p>
</blockquote>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="key-rotation"><a class="header" href="#key-rotation">Key rotation</a></h3>
<p>Key pair should be rotated on a regular basis. For references, AKS clusters rotate their service account signing key pairs <strong>every three months</strong>.</p>
<h3 id="key-retirement"><a class="header" href="#key-retirement">Key retirement</a></h3>
<p>Key pair should be retired when they are no longer needed. In most cases, this means permanently removing them to guarantee that it poses no more risk and to minimize the number of active key pairs that are being handled.</p>
<h2 id="steps-to-manually-generate-and-rotate-keys"><a class="header" href="#steps-to-manually-generate-and-rotate-keys">Steps to manually generate and rotate keys</a></h2>
<h3 id="1-generate-a-new-key-pair"><a class="header" href="#1-generate-a-new-key-pair">1. Generate a new key pair</a></h3>
<blockquote>
<p>Skip this step if you are planning to bring your own keys.</p>
</blockquote>
<pre><code class="language-bash">openssl genrsa -out sa-new.key 2048
openssl rsa -in sa-new.key -pubout -out sa-new.pub
</code></pre>
<h3 id="2-backup-the-old-key-pair-and-distribute-the-new-key-pair"><a class="header" href="#2-backup-the-old-key-pair-and-distribute-the-new-key-pair">2. Backup the old key pair and distribute the new key pair</a></h3>
<p>Schedule a jump pod to each control plane node, which mounts the <code>/etc/kubernetes/pki</code> folder:</p>
<blockquote>
<p><code>/etc/kubernetes/pki/sa.pub</code> and <code>/etc/kubernetes/pki/sa.key</code> are the paths of the service account key pair for a kind cluster. The paths can vary depending on your provider.</p>
</blockquote>
<pre><code class="language-bash">cat &lt;&lt; EOF | kubectl apply -f -
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: jump
  labels:
    k8s-app: jump
spec:
  selector:
    matchLabels:
      name: jump
  template:
    metadata:
      labels:
        name: jump
    spec:
      tolerations:
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      containers:
        - name: busybox
          image: busybox
          command:
            - sleep
            - &quot;3600&quot;
          volumeMounts:
              - mountPath: /etc/kubernetes/pki
                name: etc-kubernetes-pki
      volumes:
        - name: etc-kubernetes-pki
          hostPath:
            path: /etc/kubernetes/pki
EOF
</code></pre>
<p>Backup the old service account key pair to your local machine:</p>
<pre><code class="language-bash">POD_NAME=&quot;$(kubectl get po -l name=jump -ojson | jq -r '.items[0].metadata.name')&quot;
kubectl cp default/${POD_NAME}:/etc/kubernetes/pki/sa.pub sa-old.pub
kubectl cp default/${POD_NAME}:/etc/kubernetes/pki/sa.key sa-old.key
</code></pre>
<p>Distribute the new key pair to the certificate directory of each control plane node:</p>
<pre><code class="language-bash">for POD_NAME in &quot;$(kubectl get po -l name=jump -ojson | jq -r '.items[].metadata.name')&quot;; do
  kubectl cp sa-new.pub default/${POD_NAME}:/etc/kubernetes/pki/sa-new.pub
  kubectl cp sa-new.key default/${POD_NAME}:/etc/kubernetes/pki/sa-new.key
done
</code></pre>
<h3 id="3-update-the-jwks"><a class="header" href="#3-update-the-jwks">3. Update the JWKS</a></h3>
<p>In the case of service account tokens generated before you initiated the key rotation, you would need a time period where the old and new public keys exist in the JWKS. The relying party can then validate service account tokens signed by both the old and new private key.</p>
<p>Download <code>azwi</code> from our <a href="https://github.com/Azure/azure-workload-identity/releases">latest GitHub releases</a>, which is a CLI tool that helps generate the JWKS document in JSON.</p>
<p>Generate and upload the JWKS:</p>
<blockquote>
<p>Assuming you followed our <a href="topics/self-managed-clusters/../../quick-start.html">Quick Start</a> and store your OIDC discovery document and JWKS in an Azure storage account.</p>
</blockquote>
<pre><code class="language-bash">azwi jwks --public-keys sa-old.pub --public-keys sa-new.pub --output-file jwks.json
export AZURE_STORAGE_ACCOUNT=&lt;AzureStorageAccount&gt;
az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file jwks.json \
  --name openid/v1/jwks
</code></pre>
<h3 id="4-key-rotation"><a class="header" href="#4-key-rotation">4. Key Rotation</a></h3>
<p>With the new key pair distributed, you can utilize <a href="https://github.com/kvaps/kubectl-node-shell">kubectl-node-shell</a> to update the following core components arguments by spawning a root shell to each control plane node:</p>
<pre><code class="language-bash">kubectl node-shell &lt;NodeName&gt;

# Run in the root shell
# download yq (jq for yaml)
curl -L https://github.com/mikefarah/yq/releases/download/v4.12.1/yq_linux_amd64 --output /usr/bin/yq
chmod +x /usr/bin/yq

# append the new public key as an kube-apiserver argument
yq eval -i '.spec.containers[0].command |= . + [&quot;--service-account-key-file=/etc/kubernetes/pki/sa-new.pub&quot;]' /etc/kubernetes/manifests/kube-apiserver.yaml

# replace the old private key with the new private key for kube-apiserver and kube-controller-manager
sed -i 's|--service-account-signing-key-file=.*|--service-account-signing-key-file=/etc/kubernetes/pki/sa-new.key|' /etc/kubernetes/manifests/kube-apiserver.yaml
sed -i 's|--service-account-private-key-file=.*|--service-account-private-key-file=/etc/kubernetes/pki/sa-new.key|' /etc/kubernetes/manifests/kube-controller-manager.yaml
</code></pre>
<p>The commands above should trigger a restart for kube-apiserver and kube-controller-manager pod.</p>
<h3 id="5-verification"><a class="header" href="#5-verification">5. Verification</a></h3>
<p>Create a dummy pod that uses an annotated service account.</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | kubectl apply -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    azure.workload.identity/client-id: dummy
  name: workload-identity-sa
---
apiVersion: v1
kind: Pod
metadata:
  name: dummy-pod
  labels:
    azure.workload.identity/use: &quot;true&quot;
spec:
  serviceAccountName: workload-identity-sa
  containers:
    - name: busybox
      image: busybox
      command:
        - sleep
        - &quot;3600&quot;
EOF
</code></pre>
<p>Output the projected service account token:</p>
<pre><code class="language-bash">kubectl exec dummy-pod -- cat /var/run/secrets/azure/tokens/azure-identity-token
</code></pre>
<p>Decode your token using <a href="https://jwt.io/">jwt.io</a>. The <code>kid</code> field in the token header should be the same as the <code>kid</code> of <code>azwi jwks --public-keys sa-new.pub | jq -r '.keys[0].kid'</code>. This means that the service account token is signed by the new private key.</p>
<h3 id="6-cleanup"><a class="header" href="#6-cleanup">6. Cleanup</a></h3>
<p>Delete the dangling resources created above:</p>
<pre><code class="language-bash">kubectl delete ds jump
kubectl delete pod dummy-pod
kubectl delete sa workload-identity-sa
</code></pre>
<h3 id="7-remove-old-jwk-after-maximum-token-expiration"><a class="header" href="#7-remove-old-jwk-after-maximum-token-expiration">7. Remove old JWK after maximum token expiration</a></h3>
<p>After the maximum token expiration (the default expiration is 24 hours) has passed, projected service account tokens signed by the old private key will be rotated by kubelet and signed with the new signing key. The kubelet proactively rotates the token if it is older than 80% of its total TTL, or if the token is older than 24 hours. You should update the JWKS accordingly to only include the new public key:</p>
<pre><code class="language-bash">azwi jwks --public-keys sa-new.pub --output-file jwks.json
az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file jwks.json \
  --name openid/v1/jwks
</code></pre>
<p>Remove the old public key from kube-apiserver’s arguments:</p>
<pre><code class="language-bash"># get the index of the old public key from the kube-apiserver argument array
INDEX=&quot;$(yq e '.spec.containers[0].command' /etc/kubernetes/manifests/kube-apiserver.yaml | grep -Fn 'service-account-key-file' | head -n 1 | cut -d':' -f1)&quot;

# convert to zero-index
INDEX=&quot;$(expr ${INDEX} - 1)&quot;

# remove the old public key argument using yq
yq eval -i &quot;del(.spec.containers[0].command[${INDEX}])&quot; /etc/kubernetes/manifests/kube-apiserver.yaml

# remove the old key pair from disk
rm sa.*
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>This section contains examples about setting up a self-managed cluster with the required configurations.</p>
<table><thead><tr><th>Tool</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><a href="https://kind.sigs.k8s.io/">Kubernetes in Docker</a> (kind)</td><td>Run local Kubernetes clusters using Docker container. A fast way to create a conformant Kubernetes cluster. Great for local testing and development.</td><td><a href="topics/self-managed-clusters/./examples/kind.html">Link</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes-in-docker-kind"><a class="header" href="#kubernetes-in-docker-kind">Kubernetes in Docker (kind)</a></h1>
<ul>
<li><a href="topics/self-managed-clusters/examples/kind.html#1-complete-the-self-managed-cluster-installation-guide">1. Complete the self-managed cluster installation guide</a></li>
<li><a href="topics/self-managed-clusters/examples/kind.html#2-create-a-kind-cluster">2. Create a kind cluster</a></li>
</ul>
<p>This document shows you how to create a kind cluster and customize the required <a href="topics/self-managed-clusters/examples/../../../installation/self-managed-clusters/configurations.html">configuration</a> for the kube-apiserver.</p>
<h2 id="1-complete-the-self-managed-cluster-installation-guide"><a class="header" href="#1-complete-the-self-managed-cluster-installation-guide">1. Complete the self-managed cluster installation guide</a></h2>
<ul>
<li><a href="topics/self-managed-clusters/examples/../../../installation/self-managed-clusters/service-account-key-generation.html">Service Account Key Generation</a></li>
<li><a href="topics/self-managed-clusters/examples/../../../installation/self-managed-clusters/oidc-issuer.html">OpenID Connect Issuer</a></li>
</ul>
<h2 id="2-create-a-kind-cluster"><a class="header" href="#2-create-a-kind-cluster">2. Create a kind cluster</a></h2>
<p>Export the following environment variables:</p>
<pre><code class="language-bash">export SERVICE_ACCOUNT_ISSUER=&quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/&quot;
export SERVICE_ACCOUNT_KEY_FILE=&quot;$(pwd)/sa.pub&quot;
export SERVICE_ACCOUNT_SIGNING_KEY_FILE=&quot;$(pwd)/sa.key&quot;
</code></pre>
<p>Create a kind cluster with one control plane node and customize various service account related flags for the kube-apiserver:</p>
<blockquote>
<p>The minimum supported Kubernetes version for the webhook is v1.18, however, we recommend using Kubernetes version v1.20+.</p>
</blockquote>
<pre><code class="language-yaml">cat &lt;&lt;EOF | kind create cluster --name azure-workload-identity --image kindest/node:v1.22.4 --config=-
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraMounts:
    - hostPath: ${SERVICE_ACCOUNT_KEY_FILE}
      containerPath: /etc/kubernetes/pki/sa.pub
    - hostPath: ${SERVICE_ACCOUNT_SIGNING_KEY_FILE}
      containerPath: /etc/kubernetes/pki/sa.key
  kubeadmConfigPatches:
  - |
    kind: ClusterConfiguration
    apiServer:
      extraArgs:
        service-account-issuer: ${SERVICE_ACCOUNT_ISSUER}
        service-account-key-file: /etc/kubernetes/pki/sa.pub
        service-account-signing-key-file: /etc/kubernetes/pki/sa.key
    controllerManager:
      extraArgs:
        service-account-private-key-file: /etc/kubernetes/pki/sa.key
EOF
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">Creating cluster &quot;azure-workload-identity&quot; ...
 • Ensuring node image (kindest/node:v1.22.4) 🖼  ...
 ✓ Ensuring node image (kindest/node:v1.22.4) 🖼
 • Preparing nodes 📦   ...
 ✓ Preparing nodes 📦
 • Writing configuration 📜  ...
 ✓ Writing configuration 📜
 • Starting control-plane 🕹️  ...
 ✓ Starting control-plane 🕹️
 • Installing CNI 🔌  ...
 ✓ Installing CNI 🔌
 • Installing StorageClass 💾  ...
 ✓ Installing StorageClass 💾
Set kubectl context to &quot;kind-azure-workload-identity&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-azure-workload-identity

Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community 🙂
</code></pre>
</details>
<p>Run the following command to verify that the kind cluster is online:</p>
<pre><code class="language-bash">kubectl get nodes
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">NAME                                     STATUS   ROLES                  AGE     VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE       KERNEL-VERSION     CONTAINER-RUNTIME
azure-workload-identity-control-plane   Ready    control-plane,master   2m28s   v1.22.4   172.18.0.2    &lt;none&gt;        Ubuntu 21.04   5.4.0-1047-azure   containerd://1.5.2
</code></pre>
</details>
<p>Now that we have confirmed the cluster is up and running with the required configuration, you can follow the tutorial in <a href="topics/self-managed-clusters/examples/../../../quick-start.html">Quick Start</a> to learn the basics of how to use the Azure AD Workload Identity webhook to acquire a token to access a secret in an <a href="topics/self-managed-clusters/examples/../../../installation/self-managed-clusters/configurations.html">Azure Key Vault</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-specific-examples"><a class="header" href="#language-specific-examples">Language-Specific Examples</a></h1>
<p>Azure AD Workload Identity works especially well with the <a href="https://azure.microsoft.com/downloads/">Azure SDK</a> and the <a href="https://docs.microsoft.com/azure/active-directory/develop/msal-overview">Microsoft Authentication Library (MSAL)</a>. Your workload can leverage any of these library to seamlessly access Azure cloud resources. This section contains example projects using both libraries in different programming languages.</p>
<blockquote>
<p>You can swap the demo image used in the <a href="topics/../quick-start.html#7-deploy-workload">quick start</a> with images built from these example projects.</p>
</blockquote>
<!-- markdown-link-check-disable-next-line -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="azure-identity-client-libraries"><a class="header" href="#azure-identity-client-libraries">Azure Identity client libraries</a></h1>
<p>For details on Workload Identity support in the Azure Identity client libraries, see <a href="https://learn.microsoft.com/azure/aks/workload-identity-overview#azure-identity-client-libraries">Azure Identity client libraries</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microsoft-authentication-library-msal"><a class="header" href="#microsoft-authentication-library-msal">Microsoft Authentication Library (MSAL)</a></h1>
<table><thead><tr><th>Language</th><th>Library</th><th>Image</th><th>Example</th><th>Has Windows Images</th></tr></thead><tbody>
<tr><td>C#</td><td><a href="https://github.com/AzureAD/microsoft-authentication-library-for-dotnet">microsoft-authentication-library-for-dotnet</a></td><td><code>ghcr.io/azure/azure-workload-identity/msal-net</code></td><td><a href="https://github.com/Azure/azure-workload-identity/tree/main/examples/msal-net/akvdotnet">Link</a></td><td>✅</td></tr>
<tr><td>Go</td><td><a href="https://github.com/AzureAD/microsoft-authentication-library-for-go">microsoft-authentication-library-for-go</a></td><td><code>ghcr.io/azure/azure-workload-identity/msal-go</code></td><td><a href="https://github.com/Azure/azure-workload-identity/tree/main/examples/msal-go">Link</a></td><td>✅</td></tr>
<tr><td>Java</td><td><a href="https://github.com/AzureAD/microsoft-authentication-library-for-java">microsoft-authentication-library-for-java</a></td><td><code>ghcr.io/azure/azure-workload-identity/msal-java</code></td><td><a href="https://github.com/Azure/azure-workload-identity/tree/main/examples/msal-java">Link</a></td><td>❌</td></tr>
<tr><td>JavaScript/TypeScript</td><td><a href="https://github.com/AzureAD/microsoft-authentication-library-for-js">microsoft-authentication-library-for-js</a></td><td><code>ghcr.io/azure/azure-workload-identity/msal-node</code></td><td><a href="https://github.com/Azure/azure-workload-identity/tree/main/examples/msal-node">Link</a></td><td>❌</td></tr>
<tr><td>Python</td><td><a href="https://github.com/AzureAD/microsoft-authentication-library-for-python">microsoft-authentication-library-for-python</a></td><td><code>ghcr.io/azure/azure-workload-identity/msal-python</code></td><td><a href="https://github.com/Azure/azure-workload-identity/tree/main/examples/msal-python">Link</a></td><td>❌</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-provided-by-azure-workload-identity"><a class="header" href="#metrics-provided-by-azure-workload-identity">Metrics provided by Azure Workload Identity</a></h1>
<p>The Azure Workload Identity mutating admission webhook uses <a href="https://opentelemetry.io/">opentelemetry</a> for reporting metrics.</p>
<p>Prometheus is the only exporter that’s currently supported.</p>
<h2 id="list-of-metrics-provided-by-azure-workload-identity"><a class="header" href="#list-of-metrics-provided-by-azure-workload-identity">List of metrics provided by Azure Workload Identity</a></h2>
<table><thead><tr><th>Metric</th><th>Description</th><th>Tags</th></tr></thead><tbody>
<tr><td><code>azwi_mutation_request_bucket</code></td><td>Distribution of how long it took for the azure-workload-identity mutation request</td><td><code>namespace</code></td></tr>
</tbody></table>
<p>Metrics are served from port 8095, but this port is not exposed outside the pod by default. Use kubectl port-forward to access the metrics over localhost:</p>
<pre><code class="language-bash">kubectl port-forward deploy/azure-wi-webhook-controller-manager -n azure-workload-identity-system 8095:8095 &amp;
curl localhost:8095/metrics
</code></pre>
<h3 id="sample-metrics-output"><a class="header" href="#sample-metrics-output">Sample Metrics output</a></h3>
<pre><code class="language-shell">azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.001&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.002&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.003&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.004&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.005&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.006&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.007&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.008&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.009&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.01&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.02&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.03&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.04&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.05&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.06&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.07&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.08&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.09&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.1&quot;} 0
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.2&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.3&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.4&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.5&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.6&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.7&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.8&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;0.9&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;1&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;1.5&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;2&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;2.5&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;3&quot;} 1
azwi_mutation_request_bucket{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;,le=&quot;+Inf&quot;} 1
azwi_mutation_request_sum{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;} 0.104694953
azwi_mutation_request_count{namespace=&quot;default&quot;,service_name=&quot;webhook&quot;,telemetry_sdk_language=&quot;go&quot;,telemetry_sdk_name=&quot;opentelemetry&quot;,telemetry_sdk_version=&quot;0.20.0&quot;} 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<ul>
<li><a href="faq.html#how-does-the-azwi-cli-differ-from-the-azure-cli">How does the azwi-cli differ from the azure-cli?</a></li>
<li><a href="faq.html#how-is-azure-workload-identity-different-from-aad-pod-identity-v2">How is azure-workload-identity different from aad-pod-identity v2?</a></li>
<li><a href="faq.html#how-to-federate-multiple-identities-with-a-kubernetes-service-account">How to federate multiple identities with a Kubernetes service account?</a></li>
<li><a href="faq.html#how-to-federate-multiple-kubernetes-service-accounts-with-a-single-identity">How to federate multiple Kubernetes service accounts with a single identity?</a></li>
<li><a href="faq.html#is-there-a-propagation-delay-after-creating-a-federated-identity-credential">Is there a propagation delay after creating a federated identity credential?</a></li>
<li><a href="faq.html#what-is-the-azure-workload-identity-release-schedule">What is the Azure Workload Identity release schedule?</a></li>
<li><a href="faq.html#what-permissions-are-required-to-create-a-federated-identity-credential-for-azure-ad-application">What permissions are required to create a federated identity credential for Azure AD Application?</a></li>
<li><a href="faq.html#what-permissions-are-required-to-create-a-federated-identity-credential-for-user-assigned-managed-identity">What permissions are required to create a federated identity credential for user-assigned managed identity?</a></li>
<li><a href="faq.html#how-to-migrate-from-aad-pod-identity">How to migrate from <code>aad-pod-identity</code>?</a></li>
<li><a href="faq.html#does-workload-identity-work-in-disconnected-environments">Does Workload Identity work in disconnected environments?</a></li>
</ul>
<h2 id="how-does-the-azwi-cli-differ-from-the-azure-cli"><a class="header" href="#how-does-the-azwi-cli-differ-from-the-azure-cli">How does the azwi-cli differ from the azure-cli?</a></h2>
<p>The azwi-cli tool is specific to the Azure Workload Identity support in Kubernetes to group several manual steps (e.g. the creation of federated identity credential, annotated service accounts, etc) and automate them. Comparing with the azure-cli, it does not have an official command to add/delete federated identity (configuring federated identity credential with <code>az rest</code> is available <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/workload-identity-federation-create-trust">here</a>)</p>
<p>Azure CLI and AKS are currently working on the above requirements, as well as an Azure CLI extension that natively integrate this project with AKS clusters.</p>
<h2 id="how-is-azure-workload-identity-different-from-aad-pod-identity-v2"><a class="header" href="#how-is-azure-workload-identity-different-from-aad-pod-identity-v2">How is azure-workload-identity different from aad-pod-identity v2?</a></h2>
<p>Azure Workload Identity is v2 of the AAD Pod Identity. AAD Pod Identity v2 was a placeholder name and is now rebranded as Azure Workload Identity.</p>
<h2 id="how-to-federate-multiple-identities-with-a-kubernetes-service-account"><a class="header" href="#how-to-federate-multiple-identities-with-a-kubernetes-service-account">How to federate multiple identities with a Kubernetes service account?</a></h2>
<p>It is possible to have a many-to-one relationship between multiple identities and a Kubernetes service account, i.e. you can create multiple
federated identity credentials that reference the same service account in your Kubernetes cluster.</p>
<p><code>azure.workload.identity/client-id</code> annotation in your service account represents the default identity client ID used by the Azure Identity SDK during authentication. If you would like to use a different identity, you would need to specify the client ID when creating the Azure Credential object.</p>
<p>For example, if you are using the <a href="https://docs.microsoft.com/en-us/python/api/azure-identity/azure.identity.defaultazurecredential?view=azure-python"><code>DefaultAzureCredential</code></a> from the Azure Identity Python SDK to authenticate your application, you can specify which identity to use by adding the <code>managed_identity_client_id</code> parameter to the <code>DefaultAzureCredential</code> constructor.</p>
<h2 id="how-to-federate-multiple-kubernetes-service-accounts-with-a-single-identity"><a class="header" href="#how-to-federate-multiple-kubernetes-service-accounts-with-a-single-identity">How to federate multiple Kubernetes service accounts with a single identity?</a></h2>
<p>It is possible to have a many-to-one relationship between a single identity and multiple Kubernetes service accounts, i.e. you can create a federated identity credential for every &lt;service account namespace, service account name, OIDC issuer&gt; tuple that you want to federate with the same identity.</p>
<h2 id="is-there-a-propagation-delay-after-creating-a-federated-identity-credential"><a class="header" href="#is-there-a-propagation-delay-after-creating-a-federated-identity-credential">Is there a propagation delay after creating a federated identity credential?</a></h2>
<p>It takes a few seconds for the federated identity credential to be propagated after being initially added. If a token request is made immediately after adding the federated identity credential, it <strong>might</strong> lead to failure for a couple of minutes as the cache is populated in the directory with old data. To avoid this issue, you can add a slight delay after adding the federated identity credential.</p>
<h2 id="what-is-the-azure-workload-identity-release-schedule"><a class="header" href="#what-is-the-azure-workload-identity-release-schedule">What is the Azure Workload Identity release schedule?</a></h2>
<p>Currently, we release on a monthly basis, targeting the last week of the month.</p>
<h2 id="what-permissions-are-required-to-create-a-federated-identity-credential-for-azure-ad-application"><a class="header" href="#what-permissions-are-required-to-create-a-federated-identity-credential-for-azure-ad-application">What permissions are required to create a federated identity credential for Azure AD Application?</a></h2>
<p>One of the following roles is required:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/azure/active-directory/roles/permissions-reference#application-administrator">Application Administrator</a></li>
<li><a href="https://learn.microsoft.com/en-us/azure/active-directory/roles/permissions-reference#application-developer">Application Developer</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles#cloud-application-administrator">Cloud Application Administrator</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles#application-owner">Application Owner</a></li>
</ul>
<p>Required permissions to create/update/delete federated identity credential:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/azure/active-directory/roles/custom-available-permissions#microsoftdirectoryapplicationscredentialsupdate"><code>microsoft.directory/applications/credentials/update</code></a></li>
</ul>
<h2 id="what-permissions-are-required-to-create-a-federated-identity-credential-for-user-assigned-managed-identity"><a class="header" href="#what-permissions-are-required-to-create-a-federated-identity-credential-for-user-assigned-managed-identity">What permissions are required to create a federated identity credential for user-assigned managed identity?</a></h2>
<p>One of the following roles is required:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/azure/role-based-access-control/built-in-roles#owner">Owner</a></li>
<li><a href="https://learn.microsoft.com/en-us/azure/role-based-access-control/built-in-roles#contributor">Contributor</a></li>
</ul>
<p>Required permissions to create/update/delete federated identity credential:</p>
<ul>
<li><code>Microsoft.ManagedIdentity/userAssignedIdentities/federatedIdentityCredentials/write</code></li>
<li><code>Microsoft.ManagedIdentity/userAssignedIdentities/federatedIdentityCredentials/delete</code></li>
</ul>
<h2 id="how-to-migrate-from-aad-pod-identity"><a class="header" href="#how-to-migrate-from-aad-pod-identity">How to migrate from <code>aad-pod-identity</code>?</a></h2>
<p>You can refer to <a href="https://learn.microsoft.com/azure/aks/workload-identity-migrate-from-pod-identity">this link</a> for more information.</p>
<p>tl;dr:</p>
<ol>
<li>If you use <code>DefaultAzureCredential</code> in your workload, you can update the Azure Identity client library version to the latest that supports Workload Identity (ref: <a href="https://azure.github.io/azure-workload-identity/docs/topics/language-specific-examples/azure-identity-sdk.html">link</a>).</li>
<li>If you still have workloads that get managed identity token from IMDS, you can annotate the pod to get a proxy sidecar injected, that’ll do the token exchange with the new flow.</li>
</ol>
<h2 id="does-workload-identity-work-in-disconnected-environments"><a class="header" href="#does-workload-identity-work-in-disconnected-environments">Does Workload Identity work in disconnected environments?</a></h2>
<p>No, Workload Identity doesn’t work in completely disconnected environments. The AAD token is valid for 24 hours, so the workload needs to be connected to the network at least once every 24 hours to refresh the token.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<ul>
<li><a href="troubleshooting.html#logging">Logging</a>
<ul>
<li><a href="troubleshooting.html#mutating-admission-webhook">Mutating Admission Webhook</a>
<ul>
<li><a href="troubleshooting.html#isolate-errors-from-logs">Isolate errors from logs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="troubleshooting.html#aadsts70021-no-matching-federated-identity-record-found-for-presented-assertion">AADSTS70021: No matching federated identity record found for presented assertion.</a></li>
<li><a href="troubleshooting.html#aadsts90061-request-to-external-oidc-endpoint-failed">AADSTS90061: Request to External OIDC endpoint failed.</a></li>
<li><a href="troubleshooting.html#workload-pod-doesnt-have-the-azure-specific-environment-variables-and-projected-service-account-token-volume-after-upgrading-to-v100">Workload pod doesn’t have the Azure specific environment variables and projected service account token volume after upgrading to v1.0.0</a></li>
</ul>
<p>An overview of a list of components to assist in troubleshooting.</p>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>Below is a list of commands you can use to view relevant logs of azure-workload-identity components.</p>
<h3 id="mutating-admission-webhook-1"><a class="header" href="#mutating-admission-webhook-1">Mutating Admission Webhook</a></h3>
<p>To get the logs of the mutating admission webhook, run the following command:</p>
<pre><code class="language-bash">kubectl logs -n azure-workload-identity-system -l app=workload-identity-webhook
</code></pre>
<h4 id="isolate-errors-from-logs"><a class="header" href="#isolate-errors-from-logs">Isolate errors from logs</a></h4>
<p>You can use <code>grep ^E</code> and <code>--since</code> flag from kubectl to isolate any errors occurred after a given duration.</p>
<pre><code class="language-bash">kubectl logs -n azure-workload-identity-system -l app=workload-identity-webhook --since=1h | grep ^E
</code></pre>
<blockquote>
<p>It is always a good idea to include relevant logs from the webhook when opening a new <a href="https://github.com/Azure/azure-workload-identity/issues/new">issue</a></p>
</blockquote>
<h2 id="aadsts70021-no-matching-federated-identity-record-found-for-presented-assertion"><a class="header" href="#aadsts70021-no-matching-federated-identity-record-found-for-presented-assertion">AADSTS70021: No matching federated identity record found for presented assertion.</a></h2>
<pre><code>token_credential.go:70] &quot;failed to acquire token&quot; err=&quot;FromAssertion(): http call(https://login.microsoftonline.com//{tenant-id}//oauth2/v2.0/token)(POST) error: reply status code was 400:\n{\&quot;error\&quot;:\&quot;invalid_request\&quot;,\&quot;error_description\&quot;:\&quot;AADSTS70021: No matching federated identity record found for presented assertion. Assertion Issuer: 'https://oidc.prod-aks.azure.com/XXXXXX/'. Assertion Subject: 'system:serviceaccount:default:workload-identity-sa'. Assertion Audience: 'api://AzureADTokenExchange'.\\r\\nTrace ID: b0f62116-10b6-4a73-bdb2-281524404e00\\r\\nCorrelation ID: 4a42e576-85bc-46ae-b7e3-b52cb8958917\\r\\nTimestamp: 2022-01-20 22:54:42Z\&quot;,\&quot;error_codes\&quot;:[70021],\&quot;timestamp\&quot;:\&quot;2022-01-20 22:54:42Z\&quot;,\&quot;trace_id\&quot;:\&quot;b0f62116-10b6-4a73-bdb2-281524404e00\&quot;,\&quot;correlation_id\&quot;:\&quot;4a42e576-85bc-46ae-b7e3-b52cb8958917\&quot;,\&quot;error_uri\&quot;:\&quot;https://login.microsoftonline.com/error?code=70021\&quot;}&quot;
E0120 22:55:12.472912       1 token_credential.go:70] &quot;failed to acquire token&quot; err=&quot;FromAssertion(): http call(https://login.microsoftonline.com/{tenant-id}/oauth2/v2.0/token)(POST) error: reply status code was 400:\n{\&quot;error\&quot;:\&quot;invalid_request\&quot;,\&quot;error_description\&quot;:\&quot;AADSTS70021: No matching federated identity record found for presented assertion. Assertion Issuer: 'https://oidc.prod-aks.azure.com/XXXXXX/'. Assertion Subject: 'system:serviceaccount:default:workload-identity-sa'. Assertion Audience: 'api://AzureADTokenExchange'.\\r\\nTrace ID: 8f29172d-bf0d-4165-9d86-816665612d00\\r\\nCorrelation ID: 472f3de0-666f-411e-8d4c-cd46b6d6db26\\r\\nTimestamp: 2022-01-20 22:55:12Z\&quot;,\&quot;error_codes\&quot;:[70021],\&quot;timestamp\&quot;:\&quot;2022-01-20 22:55:12Z\&quot;,\&quot;trace_id\&quot;:\&quot;8f29172d-bf0d-4165-9d86-816665612d00\&quot;,\&quot;correlation_id\&quot;:\&quot;472f3de0-666f-411e-8d4c-cd46b6d6db26\&quot;,\&quot;error_uri\&quot;:\&quot;https://login.microsoftonline.com/error?code=70021\&quot;}&quot;
</code></pre>
<p>If you encounter the error above, it means that the issuer of the service account token does not match the issuer you defined in the federated identity credential. In the case of an AKS cluster with OIDC issuer enabled, the most common cause is when the user is missing the trailing <code>/</code> when creating the federated identity credential (e.g. <code>https://oidc.prod-aks.azure.com/XXXXXX</code> vs <code>https://oidc.prod-aks.azure.com/XXXXXX/</code>).</p>
<p>You can follow <a href="./installation/managed-clusters.html#steps-to-get-the-oidc-issuer-url-from-a-generic-managed-cluster">this guide</a> on how to get the token issuer of your cluster.</p>
<h2 id="aadsts90061-request-to-external-oidc-endpoint-failed"><a class="header" href="#aadsts90061-request-to-external-oidc-endpoint-failed">AADSTS90061: Request to External OIDC endpoint failed.</a></h2>
<pre><code> ---&gt; MSAL.NetCore.4.39.0.0.MsalServiceException:
        ErrorCode: invalid_request
Microsoft.Identity.Client.MsalServiceException: AADSTS90061: Request to External OIDC endpoint failed.
Trace ID: 86c81de3-efbd-4c0f-854d-cb8f329e5b00
Correlation ID: a92568a5-cc37-4136-ad4d-1ba82988abc2
Timestamp: 2022-10-21 04:36:48Z
   at Microsoft.Identity.Client.Internal.Requests.RequestBase.HandleTokenRefreshErrorAsync(MsalServiceException e, MsalAccessTokenCacheItem cachedAccessTokenItem)
   at Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest.ExecuteAsync(CancellationToken cancellationToken)
   at Microsoft.Identity.Client.Internal.Requests.RequestBase.RunAsync(CancellationToken cancellationToken)
   at Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor.ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken)
   at Azure.Identity.AbstractAcquireTokenParameterBuilderExtensions.ExecuteAsync[T](AbstractAcquireTokenParameterBuilder`1 builder, Boolean async, CancellationToken cancellationToken)
   at Azure.Identity.MsalConfidentialClient.AcquireTokenForClientCoreAsync(String[] scopes, String tenantId, Boolean async, CancellationToken cancellationToken)
   at Azure.Identity.MsalConfidentialClient.AcquireTokenForClientAsync(String[] scopes, String tenantId, Boolean async, CancellationToken cancellationToken)
   at Azure.Identity.ClientAssertionCredential.GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken)
        StatusCode: 400
        ResponseBody: {&quot;error&quot;:&quot;invalid_request&quot;,&quot;error_description&quot;:&quot;AADSTS90061: Request to External OIDC endpoint failed.\r\nTrace ID: 86c81de3-efbd-4c0f-854d-cb8f329e5b00\r\nCorrelation ID: a92568a5-cc37-4136-ad4d-1ba82988abc2\r\nTimestamp: 2022-10-21 04:36:48Z&quot;,&quot;error_codes&quot;:[90061],&quot;timestamp&quot;:&quot;2022-10-21 04:36:48Z&quot;,&quot;trace_id&quot;:&quot;86c81de3-efbd-4c0f-854d-cb8f329e5b00&quot;,&quot;correlation_id&quot;:&quot;a92568a5-cc37-4136-ad4d-1ba82988abc2&quot;}
...
</code></pre>
<p>If you encounter the error above, it means the OIDC issuer endpoint is not exposed to the internet or is inaccessible. You can verify this by running the following commands to check if the endpoints are accessible:</p>
<pre><code class="language-bash">export SERVICE_ACCOUNT_ISSUER=&quot;&lt;your service account issuer url&gt;&quot; # see section 1.1 on how to get the service account issuer url

# check if the OIDC issuer endpoint is accessible
curl ${SERVICE_ACCOUNT_ISSUER}/.well-known/openid-configuration
curl ${SERVICE_ACCOUNT_ISSUER}/openid/v1/jwks
</code></pre>
<!-- markdown-link-check-disable-next-line -->
<p>If you’re seeing this issue with an AKS cluster, to resolve the issue try to reconcile the cluster by running <a href="https://learn.microsoft.com/cli/azure/aks?view=azure-cli-latest#az-aks-update"><code>az aks update</code></a>. If the issue persists after reconciliation, create an <a href="https://azure.microsoft.com/support/create-ticket">Azure support ticket</a>.</p>
<h2 id="workload-pod-doesnt-have-the-azure-specific-environment-variables-and-projected-service-account-token-volume-after-upgrading-to-v100"><a class="header" href="#workload-pod-doesnt-have-the-azure-specific-environment-variables-and-projected-service-account-token-volume-after-upgrading-to-v100">Workload pod doesn’t have the Azure specific environment variables and projected service account token volume after upgrading to v1.0.0</a></h2>
<p>As of v1.0.0 release, the azure-workload-identity mutating admission webhook is defaulting to using <code>failurePolicy: Fail</code> instead of <code>Ignore</code>. With this change, we have added an <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector">object selector</a> in the configuration to only intercept and mutate pods that have the <code>azure.workload.identity/use: &quot;true&quot;</code> label. This change reduces the latency impact of the webhook and prevents workload pods that require the injected environment variables and projected service account token volume from starting in an unexpected state. Refer to <a href="https://github.com/Azure/azure-workload-identity/issues/601">issue</a> for more details.</p>
<p>If you are upgrading from a previous version of the azure-workload-identity, you will need to add the <code>azure.workload.identity/use: &quot;true&quot;</code> label to your workload pods to ensure that the mutating admission webhook is able to inject the required environment variables and projected service account token volume.</p>
<p>Run the following command to check if the workload pod is labeled:</p>
<pre><code class="language-bash">kubectl get pod quick-start -n oidc -o jsonpath='{.metadata.labels.azure\.workload\.identity/use}'
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">kubectl get pod quick-start -n oidc -o jsonpath='{.metadata.labels.azure\.workload\.identity/use}'
true
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h1>
<ul>
<li><a href="known-issues.html#permission-denied-when-reading-the-projected-service-account-token-file">Permission denied when reading the projected service account token file</a></li>
<li><a href="known-issues.html#user-tried-to-log-in-to-a-device-from-a-platform-unknown-thats-currently-not-supported-through-conditional-access-policy">User tried to log in to a device from a platform (Unknown) that’s currently not supported through Conditional Access policy</a></li>
<li><a href="known-issues.html#environment-variables-not-injected-into-pods-deployed-in-the-kube-system-namespace-in-an-aks-cluster">Environment variables not injected into pods deployed in the kube-system namespace in an AKS cluster</a></li>
<li><a href="known-issues.html#proxy-sidecar-not-injected-into-pods-that-have-hostnetwork-true">Proxy sidecar not injected into pods that have <code>hostNetwork: true</code></a></li>
</ul>
<h2 id="permission-denied-when-reading-the-projected-service-account-token-file"><a class="header" href="#permission-denied-when-reading-the-projected-service-account-token-file">Permission denied when reading the projected service account token file</a></h2>
<p>In Kubernetes 1.18, the default mode for the projected service account token file is <code>0600</code>. This causes containers running as non-root to fail while trying to read the token file:</p>
<pre><code class="language-bash">F0826 20:03:20.113998 1 main.go:27] failed to get secret from keyvault, err: autorest/Client#Do: Preparing request failed: StatusCode=0 -- Original Error: failed to read service account token: open /var/run/secrets/azure/tokens/azure-identity-token: permission denied
</code></pre>
<p>The default mode was changed to <code>0644</code> in Kubernetes v1.19, which allows containers running as non-root to read the projected service account token.</p>
<p>If you ran into this issue, you can either:</p>
<ol>
<li>
<p>Upgrade your cluster to v1.20+ or</p>
</li>
<li>
<p>Apply the following <code>securityContext</code> field to your pod spec:</p>
</li>
</ol>
<pre><code class="language-yaml">spec:
  securityContext:
    fsGroup: 65534
</code></pre>
<h2 id="user-tried-to-log-in-to-a-device-from-a-platform-unknown-thats-currently-not-supported-through-conditional-access-policy"><a class="header" href="#user-tried-to-log-in-to-a-device-from-a-platform-unknown-thats-currently-not-supported-through-conditional-access-policy">User tried to log in to a device from a platform (Unknown) that’s currently not supported through Conditional Access policy</a></h2>
<p>When creating a federated identity credential, your request might be blocked by Azure Active Directory <a href="https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/howto-conditional-access-policy-compliant-device">Conditional Access: Require compliant devices</a> policy:</p>
<pre><code class="language-bash">az rest --method POST --uri &quot;https://graph.microsoft.com/beta/applications/${APPLICATION_OBJECT_ID}/federatedIdentityCredentials&quot; --body @body.json
AADSTS50005: User tried to log in to a device from a platform (Unknown) that's currently not supported through Conditional Access policy. Supported device platforms are: iOS, Android, Mac, and Windows flavors.
...
To re-authenticate, please run:
az login --scope https://graph.microsoft.com//.default
</code></pre>
<p>Another quick way to verify if your tenant has a conditional access policy in place:</p>
<pre><code class="language-bash">az account get-access-token --resource-type=ms-graph
</code></pre>
<p>To bypass this policy:</p>
<ul>
<li><code>az login</code> with a user account on a supported system - Windows or MacOS, and make the device compliant.</li>
<li><code>az login --service-principal</code> with a service principal which does not have the above compliance check.</li>
</ul>
<p>In the case of service principal, you will have to grant the <code>Application.ReadWrite.All</code> API permission:</p>
<pre><code class="language-bash"># get the app role ID of `Application.ReadWrite.All`
APPLICATION_OBJECT_ID=&quot;$(az ad app show --id ${APPLICATION_CLIENT_ID} --query id -otsv)&quot;
GRAPH_RESOURCE_ID=&quot;$(az ad sp list --display-name &quot;Microsoft Graph&quot; --query '[0].id' -otsv)&quot;
APPLICATION_READWRITE_ALL_ID=&quot;$(az ad sp list --display-name &quot;Microsoft Graph&quot; --query &quot;[0].appRoles[?value=='Application.ReadWrite.All' &amp;&amp; contains(allowedMemberTypes, 'Application')].id&quot; --output tsv)&quot;

URI=&quot;https://graph.microsoft.com/v1.0/servicePrincipals/${APPLICATION_OBJECT_ID}/appRoleAssignments&quot;
BODY=&quot;{'principalId':'${APPLICATION_OBJECT_ID}','resourceId':'${GRAPH_RESOURCE_ID}','appRoleId':'${APPLICATION_READWRITE_ALL_ID}'}&quot;
az rest --method post --uri &quot;${URI}&quot; --body &quot;${BODY}&quot; --headers &quot;Content-Type=application/json&quot;
</code></pre>
<h2 id="environment-variables-not-injected-into-pods-deployed-in-the-kube-system-namespace-in-an-aks-cluster"><a class="header" href="#environment-variables-not-injected-into-pods-deployed-in-the-kube-system-namespace-in-an-aks-cluster">Environment variables not injected into pods deployed in the kube-system namespace in an AKS cluster</a></h2>
<p>To protect the stability of the system and prevent custom admission controllers from impacting internal services in the kube-system, namespace AKS has an Admissions Enforcer, which automatically excludes kube-system and AKS internal namespaces. Refer to <a href="https://docs.microsoft.com/en-us/azure/aks/faq#can-admission-controller-webhooks-impact-kube-system-and-internal-aks-namespaces">doc</a> for more details.</p>
<p>If you’re deploying a pod in the <code>kube-system</code> namespace of an AKS cluster and need the environment variables, projected service account token volume injected by the Azure Workload Identity Mutating Webhook, add the <code>&quot;admissions.enforcer/disabled&quot;: &quot;true&quot;</code> label or annotation in the <a href="https://github.com/Azure/azure-workload-identity/blob/8644a217f09902fa1ac63e05cf04d9a3f3f1ebc3/deploy/azure-wi-webhook.yaml#L206-L235">MutatingWebhookConfiguration</a>.</p>
<h2 id="proxy-sidecar-not-injected-into-pods-that-have-hostnetwork-true"><a class="header" href="#proxy-sidecar-not-injected-into-pods-that-have-hostnetwork-true">Proxy sidecar not injected into pods that have <code>hostNetwork: true</code></a></h2>
<p>The proxy sidecar modifies the <code>iptables</code> rules to redirect traffic to the Azure Instance Metadata Service (IMDS) endpoint to the proxy sidecar. This is not supported when <code>hostNetwork: true</code> is set on the pod as it will modify the host’s <code>iptables</code> rules which will impact other pods running on the same host.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">Development</a></h1>
<ul>
<li><a href="development.html#setting-up">Setting up</a>
<ul>
<li><a href="development.html#base-requirements">Base requirements</a></li>
<li><a href="development.html#clone-the-repository">Clone the repository</a></li>
</ul>
</li>
<li><a href="development.html#create-a-test-cluster">Create a test cluster</a>
<ul>
<li><a href="development.html#generate-a-custom-publicprivate-key-pair">Generate a custom public/private key pair</a></li>
<li><a href="development.html#setup-the-oidc-discovery-document-and-jwks">Setup the OIDC discovery document and JWKS</a></li>
<li><a href="development.html#create-a-kind-cluster">Create a kind cluster</a></li>
</ul>
</li>
<li><a href="development.html#build-and-deploy-the-webhook">Build and deploy the webhook</a></li>
<li><a href="development.html#unit-test">Unit Test</a></li>
<li><a href="development.html#e2e-test">E2E Test</a></li>
</ul>
<h2 id="setting-up"><a class="header" href="#setting-up">Setting up</a></h2>
<h3 id="base-requirements"><a class="header" href="#base-requirements">Base requirements</a></h3>
<ol>
<li>Prerequisites from <a href="./installation.html#prerequisites">Installation</a></li>
<li>Install <a href="https://golang.org/dl/">go</a>
<ul>
<li>Get the latest patch version for go 1.20.</li>
</ul>
</li>
<li>Install <a href="https://stedolan.github.io/jq/">jq</a>
<ul>
<li><code>brew install jq</code> on macOS.</li>
<li><code>chocolatey install jq</code> on Windows.</li>
<li><code>sudo apt install jq</code> on Ubuntu Linux.</li>
</ul>
</li>
<li>Install make.</li>
</ol>
<h3 id="clone-the-repository"><a class="header" href="#clone-the-repository">Clone the repository</a></h3>
<pre><code class="language-bash">git clone https://github.com/Azure/azure-workload-identity.git $(go env GOPATH)/src/github.com/Azure/azure-workload-identity
</code></pre>
<h2 id="create-a-test-cluster"><a class="header" href="#create-a-test-cluster">Create a test cluster</a></h2>
<h3 id="generate-a-custom-publicprivate-key-pair"><a class="header" href="#generate-a-custom-publicprivate-key-pair">Generate a custom public/private key pair</a></h3>
<blockquote>
<p>Skip this step if you are planning to bring your own keys.</p>
</blockquote>
<pre><code class="language-bash">openssl genrsa -out sa.key 2048
openssl rsa -in sa.key -pubout -out sa.pub
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">Generating RSA private key, 2048 bit long modulus
..............+++
......+++
e is 65537 (0x10001)
writing RSA key
</code></pre>
</details>
<h3 id="setup-the-oidc-discovery-document-and-jwks"><a class="header" href="#setup-the-oidc-discovery-document-and-jwks">Setup the OIDC discovery document and JWKS</a></h3>
<blockquote>
<p>Skip this step if you already set up the OIDC discovery document and JWKS.</p>
</blockquote>
<p>Azure blob storage will be used to host the OIDC discovery document and JWKS. However, you can host them in anywhere, as long as they are publicly available.</p>
<pre><code class="language-bash">export AZURE_STORAGE_ACCOUNT=&quot;azwi$(openssl rand -hex 4)&quot;
export AZURE_STORAGE_CONTAINER=&quot;oidc-test&quot;
az storage account create --resource-group &quot;${RESOURCE_GROUP}&quot; --name &quot;${AZURE_STORAGE_ACCOUNT}&quot;
az storage container create --name &quot;${AZURE_STORAGE_CONTAINER}&quot; --public-access container
</code></pre>
<p>Generate and upload the OIDC discovery document:</p>
<pre><code class="language-bash">cat &lt;&lt;EOF &gt; openid-configuration.json
{
  &quot;issuer&quot;: &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/&quot;,
  &quot;jwks_uri&quot;: &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/openid/v1/jwks&quot;,
  &quot;response_types_supported&quot;: [
    &quot;id_token&quot;
  ],
  &quot;subject_types_supported&quot;: [
    &quot;public&quot;
  ],
  &quot;id_token_signing_alg_values_supported&quot;: [
    &quot;RS256&quot;
  ]
}
EOF
az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file openid-configuration.json \
  --name .well-known/openid-configuration
</code></pre>
<p>Download <code>azwi</code> from our <a href="https://github.com/Azure/azure-workload-identity/releases">latest GitHub releases</a>, which is a CLI tool that helps generate the JWKS document in JSON.</p>
<p>Generate and upload the JWKS:</p>
<pre><code class="language-bash">azwi jwks --public-keys sa.pub --output-file jwks.json
az storage blob upload \
  --container-name &quot;${AZURE_STORAGE_CONTAINER}&quot; \
  --file jwks.json \
  --name openid/v1/jwks
</code></pre>
<p>Verify that the OIDC discovery document is publicly accessible:</p>
<pre><code class="language-bash">curl -s &quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/.well-known/openid-configuration&quot;
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-json">{
  &quot;issuer&quot;: &quot;https://&lt;REDACTED&gt;.blob.core.windows.net/oidc-test/&quot;,
  &quot;jwks_uri&quot;: &quot;https://&lt;REDACTED&gt;.blob.core.windows.net/oidc-test/openid/v1/jwks&quot;,
  &quot;response_types_supported&quot;: [
    &quot;id_token&quot;
  ],
  &quot;subject_types_supported&quot;: [
    &quot;public&quot;
  ],
  &quot;id_token_signing_alg_values_supported&quot;: [
    &quot;RS256&quot;
  ]
}
</code></pre>
</details>
<h3 id="create-a-kind-cluster"><a class="header" href="#create-a-kind-cluster">Create a kind cluster</a></h3>
<p>Export the following environment variables:</p>
<pre><code class="language-bash">export SERVICE_ACCOUNT_ISSUER=&quot;https://${AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${AZURE_STORAGE_CONTAINER}/&quot;
export SERVICE_ACCOUNT_KEY_FILE=&quot;$(pwd)/sa.pub&quot;
export SERVICE_ACCOUNT_SIGNING_KEY_FILE=&quot;$(pwd)/sa.key&quot;
</code></pre>
<p>Create a kind cluster with one control plane node and customize various service account-related flags for the API server:</p>
<blockquote>
<p>The minimum supported Kubernetes version for the webhook is v1.18.0, however, we recommend using Kubernetes version v1.20.0+.</p>
</blockquote>
<pre><code class="language-bash">cat &lt;&lt;EOF | kind create cluster --name azure-workload-identity --image kindest/node:v1.22.4 --config=-
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraMounts:
    - hostPath: ${SERVICE_ACCOUNT_KEY_FILE}
      containerPath: /etc/kubernetes/pki/sa.pub
    - hostPath: ${SERVICE_ACCOUNT_SIGNING_KEY_FILE}
      containerPath: /etc/kubernetes/pki/sa.key
  kubeadmConfigPatches:
  - |
    kind: ClusterConfiguration
    apiServer:
      extraArgs:
        service-account-issuer: ${SERVICE_ACCOUNT_ISSUER}
        service-account-key-file: /etc/kubernetes/pki/sa.pub
        service-account-signing-key-file: /etc/kubernetes/pki/sa.key
EOF
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">Creating cluster &quot;azure-workload-identity&quot; ...
 • Ensuring node image (kindest/node:v1.22.4) 🖼  ...
 ✓ Ensuring node image (kindest/node:v1.22.4) 🖼
 • Preparing nodes 📦   ...
 ✓ Preparing nodes 📦
 • Writing configuration 📜  ...
 ✓ Writing configuration 📜
 • Starting control-plane 🕹️  ...
 ✓ Starting control-plane 🕹️
 • Installing CNI 🔌  ...
 ✓ Installing CNI 🔌
 • Installing StorageClass 💾  ...
 ✓ Installing StorageClass 💾
Set kubectl context to &quot;kind-azure-workload-identity&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-azure-workload-identity

Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community 🙂
</code></pre>
</details>
<p>Run the following command to verify that the kind cluster is online:</p>
<pre><code class="language-bash">kubectl get nodes
</code></pre>
<details>
<summary>Output</summary>
<pre><code class="language-bash">NAME                                     STATUS   ROLES                  AGE     VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE       KERNEL-VERSION     CONTAINER-RUNTIME
azure-workload-identity-control-plane   Ready    control-plane,master   2m28s   v1.22.4   172.18.0.2    &lt;none&gt;        Ubuntu 21.04   5.4.0-1047-azure   containerd://1.5.2
</code></pre>
</details>
<h2 id="build-and-deploy-the-webhook"><a class="header" href="#build-and-deploy-the-webhook">Build and deploy the webhook</a></h2>
<pre><code class="language-bash">export REGISTRY=&lt;YourPublicRegistry&gt;
export IMAGE_VERSION=&quot;$(git describe --tags --always)&quot;
export AZURE_TENANT_ID=&quot;...&quot;
ALL_IMAGES=webhook make clean docker-build docker-push-manifest deploy
</code></pre>
<h2 id="unit-test"><a class="header" href="#unit-test">Unit Test</a></h2>
<pre><code class="language-bash">make test
</code></pre>
<h2 id="e2e-test"><a class="header" href="#e2e-test">E2E Test</a></h2>
<pre><code class="language-bash">make test-e2e-run
</code></pre>
<p>Optional settings are:</p>
<table><thead><tr><th>Environment variables</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>GINKGO_FOCUS</code></td><td>Allow you to focus on a subset of specs using regex.</td><td></td></tr>
<tr><td><code>GINKGO_SKIP</code></td><td>Allow you to skip a subset of specs using regex.</td><td></td></tr>
<tr><td><code>GINKGO_NODES</code></td><td>The number of ginkgo workers to run the specs.</td><td><code>3</code></td></tr>
<tr><td><code>GINKGO_NO_COLOR</code></td><td>True if you want colorized output.</td><td><code>false</code></td></tr>
<tr><td><code>GINKGO_TIMEOUT</code></td><td>The test suite timeout duration.</td><td><code>5m</code></td></tr>
<tr><td><code>KUBECONFIG</code></td><td>The cluster KUBECONFIG you want to run the e2e test against.</td><td><code>${HOME}/.kube/config</code></td></tr>
<tr><td><code>E2E_EXTRA_ARGS</code></td><td>Allow you to insert extra arguments when executing the test suite.</td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="releasing"><a class="header" href="#releasing">Releasing</a></h1>
<ul>
<li><a href="development/releasing.html#1-create-a-release-pull-request">1. Create a release pull request</a></li>
<li><a href="development/releasing.html#2-review-and-approve-the-release-pull-request">2. Review and approve the release pull request</a></li>
<li><a href="development/releasing.html#3-verify-that-the-create_release-action-is-triggered-after-the-release-pull-request-is-merged">3. Verify that the <code>create_release</code> action is triggered after the release pull request is merged</a></li>
<li><a href="development/releasing.html#4-verify-that-the-tag-and-release-is-successfully-created">4. Verify that the tag and release is successfully created</a></li>
</ul>
<p>Currently, Azure Workload Identity releases on a monthly basis, targeting the last week of the month.</p>
<p>We use GitHub Actions to automate our release process.</p>
<h2 id="1-create-a-release-pull-request"><a class="header" href="#1-create-a-release-pull-request">1. Create a release pull request</a></h2>
<p><img src="development/../images/release-step-1.png" alt="Create a release pull request" /></p>
<h2 id="2-review-and-approve-the-release-pull-request"><a class="header" href="#2-review-and-approve-the-release-pull-request">2. Review and approve the release pull request</a></h2>
<p><img src="development/../images/release-step-2.png" alt="Review and approve the release pull request" /></p>
<h2 id="3-verify-that-the-create_release-action-is-triggered-after-the-release-pull-request-is-merged"><a class="header" href="#3-verify-that-the-create_release-action-is-triggered-after-the-release-pull-request-is-merged">3. Verify that the <code>create_release</code> action is triggered after the release pull request is merged</a></h2>
<p><img src="development/../images/release-step-3.png" alt="Verify that the create_release action is triggered after the release pull request is merged" /></p>
<h2 id="4-verify-that-the-tag-and-release-is-successfully-created"><a class="header" href="#4-verify-that-the-tag-and-release-is-successfully-created">4. Verify that the tag and release is successfully created</a></h2>
<p><img src="development/../images/release-step-4.png" alt="Verify that the tag and release is successfully created" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>The Azure AD Workload Identity project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit <a href="https://cla.microsoft.com">https://cla.microsoft.com</a>.</p>
<p>When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h1>
<p>This project has adopted the <a href="https://opensource.microsoft.com/codeofconduct/">Microsoft Open Source Code of Conduct</a>. For more information, see the <a href="https://opensource.microsoft.com/codeofconduct/faq">Code of Conduct FAQ</a> or contact <a href="mailto:opencode@microsoft.com">opencode@microsoft.com</a> with any additional questions or comments.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
